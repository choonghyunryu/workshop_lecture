{
  "articles": [
    {
      "path": "apt_api.html",
      "title": "공공데이터포털 오픈 API를 이용한 데이터 수집",
      "description": "공공데이터포털 오픈 API를 이용한 데이터 수집 로직을 구현해 봅니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-03",
      "contents": "\n\nContents\n공공데이터포털\n아파트매매 실거래 상세 자료 수집\nAPI 기본 정보\n요청 변수 (request parameter)\n출력 결과\n준비사항\n\n아파트매매 실거래 상세 자료 조회 프로그램 개발\n요청 URL 생성\n법정동 코드 준비하기\nAPI 호출\nXML 파싱\n다건 처리 로직\n함수의 완성\n함수의 호출\n\n\n\n\n\n\n\n들어가기\n여러분은 NAVER의 오픈 API를 다루어 보았습니다.\n\n그것은 또 다른 오픈 API를 사용할 수 있다는 것을 의미합니다.\n\n이제 여세를 몰아 여러분의 내공이 공공데이터의 수집을 갈망하게 됩니다.\n\n\n공공데이터포털\n공공데이터포털은 정부/지자체의 공공 데이터 제공을 목적으로 행정안전부에서 운영하는 사이트입니다.\n2022-02-03일 기준으로 68,323건의 데이터를 공개하고 있으며, 오픈 API로는 8,745건을 공개하고 있습니다. 모든 데이터가 질적으로 우수하다고 단언하기는 어렵지만 몇몇 데이터는 인기가 많습니다.\n데이터를 사용하기 위해서는 회원가입이 필수이며, 오픈 API를 사용하기 위해서는 활용신청 후 승인을 받아야 합니다.\n아파트매매 실거래 상세 자료 수집\n우리는 이제 국토교통부의 아파트매매 실거래 상세 자료를 수집하는 방법을 살펴봅니다. 별도의 아파트매매 실거래 자료 API가 있으므로 주의해야 합니다.\nAPI 기본 정보\n국토교통부_아파트매매 실거래 상세 자료 상세 페이지에서 여러 정보를 확인할 수 있습니다.\n출력 포맷이 XML인 API이며, API 서비스 주소는 다음과 같습니다.\n서비스 URL\nhttp://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\n\n요청 변수 (request parameter)\n요청 변수는 다음과 같습니다. 역시 인증을 위한 서비스키가 필요합니다.\n영문명의 일관성이 떨어집니다. 대문자로만 구성된 영문명과 대소문자로 구성된 영문명이 혼재합니다. 단어의 결합 방법도 다릅니다. 언더라인(_) 사용한 것과 캡문자로 구분하는 방법이 섞여있습니다.\n항목명(국문)\n항목명(영문)\n항목크기\n항목구분\n샘플데이터\n항목설명\n서비스키\nServiceKey\n20\n필수\n-\n공공데이터포털에서 받은 인증키\n페이지 번호\npageNo\n4\n옵션\n1\n페이지번호\n한 페이지 결과 수\nnumOfRows\n4\n옵션\n10\n한 페이지 결과 수\n지역코드\nLAWD_CD\n5\n필수\n11110\n지역코드\n계약월\nDEAL_YMD\n6\n필수\n201512\n계약월\n출력 결과\n출력 결과 정보는 너무 실망스럽습니다. 영문명은 일부 헤더 데이터만 제공하고, 실 데이터는 영문명없이 한글명으로 이루어져 있습니다. 이것은 한글사랑, 애국의 문제가 아닙니다.\nAPI 프로그래밍을 위해서 변수명(영문명)은 영문으로 정의되어야 합니다. 변수명은 아스키(ASCII)1 문자 안에서의 알파벳, 숫자와 르포그램언어에서 지원하는 몇개의 문자로 구성해야 합니다.\n더욱 심각한 문제는 이 정보가 현행화되어 있지 않습니다. 아마도 항목이 늘어난 것 같은데, 일부 데이터 항목이 이 상세 페이지의 출력결과에 누락되어 있습니다.\n항목명(국문)\n항목명(영문)\n항목크기\n항목구분\n샘플데이터\n항목설명\n결과코드\nresultCode\n2\n필수\n00\n결과코드\n결과메시지\nresultMsg\n50\n필수\nOK\n결과메시지\n한 페이지 결과 수\nnumOfRows\n4\n필수\n10\n한 페이지 결과 수\n페이지 번호\npageNo\n4\n필수\n1\n페이지번호\n전체 결과 수\ntotalCount\n4\n필수\n3\n전체 결과 수\n거래금액\n거래금액\n40\n필수\n82,500\n거래금액\n건축년도\n건축년도\n4\n필수\n2008\n건축년도\n년\n년\n4\n필수\n2015\n년\n도로명\n도로명\n40\n필수\n사직로8길\n도로명\n도로명건물본번호코드\n도로명건물본번호코드\n5\n필수\n00004\n도로명건물본번호코드\n도로명건물부번호코드\n도로명건물부번호코드\n5\n필수\n00000\n도로명건물부번호코드\n도로명시군구코드\n도로명시군구코드\n5\n필수\n11110\n도로명시군구코드\n도로명일련번호코드\n도로명일련번호코드\n2\n필수\n03\n도로명일련번호코드\n도로명지상지하코드\n도로명지상지하코드\n1\n필수\n0\n도로명지상지하코드\n도로명코드\n도로명코드\n7\n필수\n4100135\n도로명코드\n법정동\n법정동\n40\n필수\n사직동\n법정동\n법정동본번코드\n법정동본번코드\n4\n필수\n0009\n법정동본번코드\n법정동부번코드\n법정동부번코드\n4\n필수\n0000\n법정동부번코드\n법정동시군구코드\n법정동시군구코드\n5\n필수\n11110\n법정동시군구코드\n법정동읍면동코드\n법정동읍면동코드\n5\n필수\n11500\n법정동읍면동코드\n법정동지번코드\n법정동지번코드\n1\n필수\n1\n법정동지번코드\n아파트\n아파트\n40\n필수\n광화문풍림스페이스본(9-0)\n아파트\n월\n월\n2\n필수\n12\n월\n일\n일\n6\n필수\n1~10\n일\n일련번호\n일련번호\n14\n필수\n11110-2203\n일련번호\n전용면적\n전용면적\n20\n필수\n94.51\n전용면적\n지번\n지번\n10\n필수\n9\n지번\n지역코드\n지역코드\n5\n필수\n11110\n지역코드\n층\n층\n4\n필수\n11\n층\n오픈API 상세 화면에서 참고문서인 아파트 매매 상세자료 조회 기술문서.hwp 파일을 다운로드하면 유용하게 활용할 수 있습니다.\n\n\n\nFigure 1: 오픈API 상세 화면\n\n\n\n이 파일에는 홈페이지에서 누락된 출력 결과가 기술되어 있습니다. 다음은 파일에서의 출력결과 정보의 일부입니다.\n\n\n\nFigure 2: 출력결과 정보의 일부\n\n\n\n파일의 정보에는 영문명이 있으나, 이것은 프로그래밍을 위한 변수 이름으로 사용할 수 없겠습니다. 결국은 API 프로그램 개발자가 변수 이름을 정의해야할 것 같습니다. 아쉬운 점이 많습니다.\n준비사항\n국토교통부_아파트매매 실거래 상세 자료 상세 오픈 API를 사용하기 위해서는 활용신청을 통해서 미리 승인을 받아야 합니다.\n승인이 되면 마이페이지에서 개발계정 상세보기에서 다음과 같은 정보를 확인할 수 있습니다. 일반 인증키 역시 외부로 노출되지 않도록 주의해야 합니다. 이 서비스는 일일 트래픽이 1000회로 제한되어 있습니다.\n\n\n\nFigure 3: 개발계정 상세보기 화면\n\n\n\n아파트매매 실거래 상세 자료 조회 프로그램 개발\n요청 URL 생성\nXML 출력 포맷을 사용하기 때문에 다음 요청 URL을 사용합니다.\nhttp://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\nGET 방식의 호출 URL이기 때문에 요청변수 영역을 ?로 구분하고, 요청 변수들은 &로 구분합니다. 요청변수는 다음과 같습니다.\nServiceKey : 공공데이터포털에서 받은 인증키\npageNo : 페이지번호\nnumOfRows : 한 페이지 결과 수\nLAWD_CD : 지역코드\nDEAL_YMD : 계약월\n\n\n  api <- \"http://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\"\n  url <- glue::glue(\n    \"{api}?ServiceKey={auth_key}&pageNo={chunk_no}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n  )\n\n\n\n여기서 한가지 문제가 발생합니다. 서비스를 위해서는 지역코드가 필요합니다. 그나마 아파트 매매 상세자료 조회 기술문서.hwp 파일의 요청 메시지 명세 섹션에 “각 지역별 코드 행정표준코드관리시스템(www.code.go.kr)의 법정동코드 10자리 중 앞 5자리”라고 설명되어 있습니다.\n법정동 코드 준비하기\n만약에 서울특별시 노원구의 아파트매매 실거래 상세 자료를 조회하기 위해서는 노원구의 지역코드를 알아야 합니다.\n행정표준코드관리시스템에서 아주 어렵게 법정동 코드를 조회하는 법정동코드목록조회 화면을 찾았습니다.\n\n\n\nFigure 4: 법정동코드목록조회 화면\n\n\n\n노원구의 법정동코드가 “1135000000”임을 알았습니다. 그리고 API를 이용하기 위해서는 이 코드의 앞 다섯자리인 “11350”을 사용해야 합니다. 그런데 매번 특정 지역의 정보를 확인하기 위해서 행정표준코드관리시스템에 접속해야할까요? 그래서 “법정동 코드 전체자료”를 다운로드했습니다.\n해당 파일의 압축을 풀고, 데이터 프레임 객체를 만든 다음 R 데이터 파일과 SQLite DBMS의 테이블에 저장해 두었습니다.\n\n\nlibrary(dplyr)\nfname <- here::here(\"inst\", \"meta\", \"법정동코드 전체자료.txt\")\nlegal_divisions <- fname %>%\n  read.table(sep = \"\\t\", header = TRUE, fileEncoding = \"cp949\",\n             col.names = c(\"DIVISION_ID\", \"DIVISION_NM\", \"MAINTAIN\")) %>%\n  mutate(DIVISION_ID = format(DIVISION_ID, scientific = FALSE, trim = TRUE)) %>%\n  mutate(MAINTAIN = case_when(\n    MAINTAIN == \"존재\" ~ \"Y\",\n    MAINTAIN == \"폐지\" ~ \"N\")\n  ) %>%\n  mutate(MEGA_CD = substr(DIVISION_ID, 1, 2),\n         MEGA_NM = stringr::str_extract(DIVISION_NM, \"^[\\\\w]+\")) %>%\n  mutate(CTY_CD = substr(DIVISION_ID, 1, 5),\n         CTY_NM = stringr::str_extract(DIVISION_NM, \" [\\\\w]+\") %>%\n           stringr::str_remove(\"\\\\s\")) %>%\n  mutate(ADMI_CD = substr(DIVISION_ID, 1, 8),\n         ADMI_NM = stringr::str_remove(DIVISION_NM, \"^[\\\\w]+ [\\\\w]+ \")) %>%\n  filter(!stringr::str_detect(DIVISION_ID, \"000000$\"))\n\nsave(legal_divisions, file = \"data/legal_divisions.rda\")\n\n\ndb_name <- here::here(\"inst\", \"meta\", \"GISDB.sqlite\")\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), db_name)\nDBI::dbWriteTable(con, \"TB_LEGAL_DIVISIONS\", legal_divisions, overwrite = TRUE)\nDBI::dbDisconnect(con)\n\n\n\nAPI 호출\n만들어 놓은 url을 XML 패키지의 xmlParse()로 API를 호출합니다. 만약에 호출 결과가 정상이 아닐 경우에는 에러를 발생시킵니다. 이때, 결과에 대한 메시지를 보여줍니다.\n\n\n  doc <- XML::xmlParse(url)\n\n  resultCode <- doc %>%\n    XML::getNodeSet(\"//resultCode\") %>%\n    XML::xmlValue()\n\n  if (resultCode != \"00\") {\n    result_msg <- doc %>%\n      XML::getNodeSet(\"//resultMsg\") %>%\n      XML::xmlValue()\n\n    stop(result_msg)\n  }\n\n\n\nXML 파싱\n조회된 매매정보의 건수를 가져옵니다. 지역코드에 따라 매매정보의 건수에 대한 편차가 클 것입니다. 도심의 대규모 아파트단지를 포함한 지역은 매매건수가 많을 것이고, 아파트 수가 적은 지방의 지역은 매매건수가 적을 것입니다.\n\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//totalCount\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n\n\nXML 포멧에서는 item 태그로 개별 검색 결과를 반환합니다. 역시 getNodeSet()로 item 노드를 가져다 조작합니다. xmlToDataFrame()가 이들 개별 결과들을 데이터 프레임 객체로 변환합니다.\nget_list() 함수를 정의했습니다. 이 함수의 로직은 한글명을 영문 변수명으로 변경하는 로직과 필요한 항목만 가져오는 로직이 있습니다.\n\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      mutate(거래금액 = stringr::str_remove(거래금액, \",\") %>%\n                   as.integer()) %>%\n      mutate(DEAL_DATE = glue::glue(\"{년}-{str_pad(월, width = 2, pad = '0')}-{\n                                  str_pad(일, width = 2, pad = '0')}\")) %>%\n      mutate(층 = as.integer(층)) %>%\n      mutate(건축년도 = as.integer(건축년도)) %>%\n      select(-년, -월, -일) %>%\n      select(\"LAWD_CD\"       = 지역코드,\n             DEAL_DATE,\n             \"SERIAL\"        = 일련번호,\n             \"DEAL_TYPE\"     = 거래유형,\n             \"BUILD_NM\"      = 아파트,\n             \"FLOOR\"         = 층,\n             \"BUILD_YEAR\"    = 건축년도,\n             \"AREA\"          = 전용면적,\n             \"AMOUNT\"        = 거래금액,\n             \"ROAD_CD\"       = 도로명코드,\n             \"ROAD_NM\"       = 도로명,\n             \"BUILD_MAJOR\"   = 도로명건물본번호코드,\n             \"BUILD_MINOR\"   = 도로명건물부번호코드,\n             \"ROAD_SEQ\"      = 도로명일련번호코드,\n             \"BASEMENT_FLAG\" = 도로명지상지하코드,\n             \"LAND_NO\"       = 지번,\n             \"DONG_NM\"       = 법정동,\n             \"DONG_MAJOR\"    = 법정동본번코드,\n             \"DONG_MINOR\"    = 법정동부번코드,\n             \"EUBMYNDONG_CD\" = 법정동읍면동코드,\n             \"DONG_LAND_NO\"  = 법정동지번코드,\n             \"DEALER_ADDR\"   = 중개사소재지,\n             \"CANCEL_DEAL\"   = 해제여부,\n             \"CANCEL_DATE\"   = 해제사유발생일)\n  }\n\n  deal_list <- doc %>%\n    get_list()\n\n\n\n다건 처리 로직\n다음은 chunk 사이즈보다 큰 다건의 검색 결과 처리를 위한 로직입니다. NAVER 뉴스 검색 로직과 유사합니다.\n\n\n  records <- NROW(deal_list)\n\n  if (!do_done | records >= total_count) {\n    return(deal_list)\n  } else {\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    add_list <- (seq(cnt) + 1) %>%\n      purrr::map_df({\n        function(x) {\n          url <- glue::glue(\n            \"{api}?ServiceKey={auth_key}&pageNo={x}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n          )\n\n          XML::xmlParse(url) %>%\n            get_list()\n        }\n      })\n\n    deal_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n\n\n\n함수의 완성\n이상의 로직을 통합해서 아파트매매 실거래 상세 자료를 조회하는 함수를 다음과 같이 정의하였습니다.\n\n\ntrade_apt <- function(auth_key, LAWD_CD = \"11110\", DEAL_YMD = \"202112\",\n                      chunk_no = 1, chunk = 100, do_done = FALSE) {\n  library(dplyr)\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      mutate(거래금액 = stringr::str_remove(거래금액, \",\") %>%\n                   as.integer()) %>%\n      mutate(DEAL_DATE = glue::glue(\"{년}-{str_pad(월, width = 2, pad = '0')}-{\n                                  str_pad(일, width = 2, pad = '0')}\")) %>%\n      mutate(층 = as.integer(층)) %>%\n      mutate(건축년도 = as.integer(건축년도)) %>%\n      select(-년, -월, -일) %>%\n      select(\"LAWD_CD\"       = 지역코드,\n             DEAL_DATE,\n             \"SERIAL\"        = 일련번호,\n             \"DEAL_TYPE\"     = 거래유형,\n             \"BUILD_NM\"      = 아파트,\n             \"FLOOR\"         = 층,\n             \"BUILD_YEAR\"    = 건축년도,\n             \"AREA\"          = 전용면적,\n             \"AMOUNT\"        = 거래금액,\n             \"ROAD_CD\"       = 도로명코드,\n             \"ROAD_NM\"       = 도로명,\n             \"BUILD_MAJOR\"   = 도로명건물본번호코드,\n             \"BUILD_MINOR\"   = 도로명건물부번호코드,\n             \"ROAD_SEQ\"      = 도로명일련번호코드,\n             \"BASEMENT_FLAG\" = 도로명지상지하코드,\n             \"LAND_NO\"       = 지번,\n             \"DONG_NM\"       = 법정동,\n             \"DONG_MAJOR\"    = 법정동본번코드,\n             \"DONG_MINOR\"    = 법정동부번코드,\n             \"EUBMYNDONG_CD\" = 법정동읍면동코드,\n             \"DONG_LAND_NO\"  = 법정동지번코드,\n             \"DEALER_ADDR\"   = 중개사소재지,\n             \"CANCEL_DEAL\"   = 해제여부,\n             \"CANCEL_DATE\"   = 해제사유발생일)\n  }\n\n  api <- \"http://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\"\n  url <- glue::glue(\n    \"{api}?ServiceKey={auth_key}&pageNo={chunk_no}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n  )\n\n  doc <- XML::xmlParse(url)\n\n  resultCode <- doc %>%\n    XML::getNodeSet(\"//resultCode\") %>%\n    XML::xmlValue()\n\n  if (resultCode != \"00\") {\n    result_msg <- doc %>%\n      XML::getNodeSet(\"//resultMsg\") %>%\n      XML::xmlValue()\n\n    stop(result_msg)\n  }\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//totalCount\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n  deal_list <- doc %>%\n    get_list()\n\n  records <- NROW(deal_list)\n\n  if (!do_done | records >= total_count) {\n    return(deal_list)\n  } else {\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    add_list <- (seq(cnt) + 1) %>%\n      purrr::map_df({\n        function(x) {\n          url <- glue::glue(\n            \"{api}?ServiceKey={auth_key}&pageNo={x}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n          )\n\n          XML::xmlParse(url) %>%\n            get_list()\n        }\n      })\n\n    deal_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n}\n\n\n\n함수의 호출\n다음은 2021년 4월 서울 용산구의 아파트매매 실거래 상세 자료를 조회하는 예제입니다. 실행하면 100건의 결과를 가져옵니다.\n\n\n# Your authorized API keys\nauth_key <- \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n\nresult <- trade_apt(auth_key, LAWD_CD = \"11170\", DEAL_YMD = \"200603\")\n\n\n\n다음은 총 312건의 결과를 가져옵니다. 즉, chunk가 300이므로 함수 내부에서 2번의 API 호출이 이루어집니다.\n\n\nresult <- trade_apt(auth_key, LAWD_CD = \"11170\", DEAL_YMD = \"200603\", chunk = 300,  do_done = TRUE)\n\n\n\n\n미국정보교환표준부호(영어: American Standard Code for Information Interchange), 또는 줄여서 ASCII( /ˈæski/, 아스키)는 영문 알파벳을 사용하는 대표적인 문자 인코딩이다. 아스키는 컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에서 사용되며, 대부분의 문자 인코딩이 아스키에 기초를 두고 있다. 출처: https://ko.wikipedia.org/wiki/ASCII↩︎\n",
      "last_modified": "2022-02-11T23:02:09+09:00"
    },
    {
      "path": "cheatsheets.html",
      "title": "Tidyverse Cheatsheets",
      "description": "재현가능한 연구 관련 Cheatsheets 모음 \n",
      "author": [],
      "contents": "\n\nContents\nRStudio 사용에 날개를 달다\nRStudio\n\n정적 문서와 웹앱을 만들어 보자\nrmarkdown\nshiny\n\n논문을 작성한다면\nLaTeX\n\n\nRStudio 사용에 날개를 달다\nRStudio\nRStudio IDE 사용 방법을 정리한 RStudio의 cheatsheet\n \n정적 문서와 웹앱을 만들어 보자\nrmarkdown\n동적 데이터분석 문서 작성을 지원하는 rmarkdown 패키지의 cheatsheet\n \nshiny\n반응형 웹 앱을 개발하는 shiny 패키지의 cheatsheet\n \n논문을 작성한다면\nLaTeX\n조판 전문 시스템인 LaTeX의 cheatsheet\n \n\n\n\n",
      "last_modified": "2022-02-11T23:02:09+09:00"
    },
    {
      "path": "chunk_knitr.html",
      "title": "청크 옵션 이해하기",
      "description": "knitr R 코드 청크의 옵션을 활용하는 방법을 익힙니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-11-04",
      "contents": "\n\nContents\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n튜토리얼의 범위\n\nknitr의 R 코드 청크\n청크의 구조 이해하기\nknitr의 R 코드 청크 옵션\n\n핸즈온 준비하기\n핸즈온 파일 다운로드하기\n\n핸즈온\n1. R 코드 출력 제어하기\n2. 플롯 출력하기\n\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n들어가기\nRStudio의 R 마크다운은 기본적으로 knitr 코드 청크를 사용합니다.\n\n청크 옵션을 아는만큼 문서의 품질이 향상됩니다. 대표적인 청크 옵션을 사용하는 방법을 익혀서 여러분의 문서에 날개를 달아주기 바랍니다.\n\n\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n앞서 만들었던 첫 R 마크다운 문서를 분해하면 다음과 같습니다.\nR 마크다운 문서의 분해YAML 헤더\nR 마크다운의 헤더 영역으로, 출력 문서를 세부적으로 제어합니다.\n\nR 코드 청크\n수행할 R 코드를 포함한 영역입니다.\n\n마크다운 태그를 포함한 텍스트\n문서의 서식과 텍스트를 정의하는 영역입니다.\n\n튜토리얼의 범위\n이 튜토리얼은 R 마크다운 문서의 분해 중에서의 knitr의 R 코드 청크 옵션을 이해할 목적으로 진행합니다. 대표적인 청크 옵션을 이해하고, 다루지 않는 다른 옵션의 사용을 시도할 수 있는 자신감 함양을 유도합니다.\nknitr의 R 코드 청크\n청크의 구조 이해하기\n우리는 지금 R 코드 청크를 다루고 있습니다. 그런데 knitr은 bash sehll(리눅스 쉘 스크립트), python(파이썬) 코드 청크 외에 몇개의 코드 청크를 지원합니다.\n예를 들어 R 마크다운에서 리눅스 쉘 스크립트 청크를 사용하려면 다음과 같이 기술합니다. 이것은 리눅스에서 날짜를 조회하는 명령어인 date를 수행한 후 그 결과를 마크다운 문서에 삽입합니다.\n\nbash 코드청크\n```{bash}\n# 날짜와 일시 출력\ndate\n\n# 'YYYY-MM-DD' 포맷의 날짜 출력\ndate +'%Y-%m-%d'\n```\n수행결과\n\n# 날짜와 일시 출력\ndate\n\n# 'YYYY-MM-DD' 포맷의 날짜 출력\ndate +'%Y-%m-%d'\n## Fri Feb 11 23:02:10 KST 2022\n## 2022-02-11\n\n\n브레이스({) 뒤에 오는 ’bash’는 bash 쉘이 코드 청크를 실행하라는 의미입니다. 그러면, R에게 실행을 요청하기 위한 청크는 다음과 같이 사용합니다. 당연히 브레이스 뒤에 ’r’이 따라옵니다.\n\n\n```{r 청크이름, 옵션이름=옵션값, 옵션이름=옵션값, ...}\nR 코드 삽입 영역\n```\n\n\n청크 이름은 청크를 식별하는 식별자입니다.\n청크 이름을 기술하지 않아도 청크는 정상적으로 수행됩니다.\nR 마크다운 컴파일의 진행경과\n오류가 발생하는 청크의 인식 등을 위해 기술하는 것이 좋습니다.\n\n옵션이름 = 옵션값 형식으로 옵션을 기술합니다.\n옵션을 기술하지 않아도 됩니다.\n이 경우에는 옵션의 기본 설정값이 적용됩니다.\n\nknitr의 R 코드 청크 옵션\nknitr 홈페이지의 https://yihui.org/knitr/options/ 페이지에는 청크 옵션에 대해서 잘 설명되어 있습니다.\n다음은 대표적인 청크 옵션의 목록입니다. 이 옵션들은 반드시 숙지하시기 바랍니다.\n코드와 결과 출력 관련 청크 옵션\n튜토리얼에서 익혀야 할 출력 관련 대표적인 청크 옵션입니다.\nR 코드와 결과 출력 관련 청크 옵션 목록\n옵션\n기본값\n기능\neval\nTRUE\n청크를 실행하고, 그 결과를 삽입하는 여부 설정\necho\nTRUE\n실행한 명령어도 함께 출력하는지의 여부 설정\nwarning\nTRUE\n경고 메시지의 출력 여부 설정\nerror\nFALSE\n에러 메시지의 출력 여부 설정\nmessage\nTRUE\n경고, 에러 외의 메시지의 출력 여부 설정\ntidy\nFALSE\nR 코드를 깔끔하게 정돈해서 출력할지의 여부 설정\ncomment\n“##”\n실행 결과 출력 각 라인의 앞에 넣을 prefix\n시각화 관련 청크 옵션\n튜토리얼에서 익혀야 할 시각화 관련 대표적인 청크 옵션입니다.\nR 코드와 결과 시각화 관련 청크 옵션 목록\n옵션\n기본값\n기능\nfig.width\n7\n출력을 위해 생성할 이미지 파일의 너비, 단위: 인치.\nfig.height\n7\n출력을 위해 생성할 이미지 파일의 높이, 단위: 인치.\nfig.align\n“default”\n플롯의 정렬 방법. \"left\", \"right\", \"center\"에서 선택\nfig.path\n‘figure/’\n시각화 이미지 파일을 저장할 디렉토리 경로\nfig.cap\nNULL\n플롯의 캡션 문자 정의\nout.width\n\n시각화가 화면에 출력되는 너비, 예) “75%”, “300px”\n핸즈온 준비하기\n핸즈온 파일 다운로드하기\n핸즈온 튜토리얼을 수행하기 위해서 아래 “청크 옵션 이해하기 튜토리얼 파일” 링크의 R 마크다운 파일을 다운로드합니다.\n링크에 마우스를 올려, 오른쪽 버튼으로 “다른이름으로 파일저장”을 실행합니다.\n\n다운로드한 파일을 RStudio로 읽어들입니다.\n청크 옵션 이해하기 튜토리얼 파일\n핸즈온\n1. R 코드 출력 제어하기\n1.1. R 코드와 함께 결과 출력하기\n\n다음 지문을 수행할, 분석 경험을 위해 코드와 결과를 공유할 청크를 만들려고 합니다.\niris 데이터에서 중복인 데이터가 1건 있습니다. 추출하여 출력해 보세요.\nR 코드와 결과를 함께 출력해 보세요.\n청크 이름은 ’dup_iris’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-1. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n여러 방법이 있는데, 다음 코드를 사용해 보세요. \niris[duplicated(iris), ]\n모범 답안\n```{r dup_iris}\niris[duplicated(iris), ]\n```\n실행 결과\n\n\niris[duplicated(iris), ]\n\n\n##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n## 143          5.8         2.7          5.1         1.9 virginica\n\n\n\n1.2. 결과만 출력하기\n\n다음 지문을 수행할, 분석 결과만 공유할 청크를 만들려고 합니다.\nsummary() 함수로 iris 데이터의 각 변수들을 요약해 보세요.\n결과만 출력해 보세요.\n청크 이름은 ’dup_iris_result’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-2. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n다음 코드를 사용해 보세요. \nsummary(iris)\n모범 답안\n```{r dup_iris_result, echo=FALSE}\nsummary(iris)\n```\n실행 결과\n\n##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n##  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n##  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n##  Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n##  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n##  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n##  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n##        Species  \n##  setosa    :50  \n##  versicolor:50  \n##  virginica :50  \n##                 \n##                 \n## \n\n\n\n1.3. 소스 코드만 출력하기\n\n소스만 설명하려 합니다. 즉, 소스를 실행하지 않고, 출력만 해야 합니다.\nsummary() 함수로 iris 데이터의 각 변수들을 요약하는 소스를 출력하세요.\n청크 이름은 ’iris_not_run’으로 정의합니다.\n\n’understand_chunk.Rmd’의 1-3. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n다음 코드를 사용해 보세요. \nsummary(iris)\n모범 답안\n```{r iris_not_run, echo=TRUE, eval=FALSE}\nsummary(iris)\n```\n실행 결과\n\n\nsummary(iris)\n\n\n\n\n\n1.4. 경고 메시지 출력하기\n\n다음을 수행해 보세요.\n-2부터 2까지의 정수 5개의 로그 값을 계산해 보세요.\n청크 이름은 ’log_integer’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-4. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n어떤 결과가 출력되었나요?\n음수일 경우에 발생하는 경고 메시가 출력됨을 확인하세요.\n\n\n\n힌트 보기\n다음 코드를 사용해 보세요. \nlog(-3:3)\n모범 답안\n```{r log_integer}\nlog(-3:3)\n```\n실행 결과\n\n\nlog(-3:3)\n\n\n## Warning in log(-3:3): NaNs produced\n## [1]       NaN       NaN       NaN      -Inf 0.0000000 0.6931472\n## [7] 1.0986123\n\n\n\n1.5. 경고 메시지 출력하지 않기\n\n다음을 수행할 때 경고 메시지가 출력되는 것을 이미 알고 있습니다.\n-2부터 2까지의 정수 5개의 로그 값을 계산해 보세요.\n경고 메시지를 출력하고 싶지 않습니다.\n청크 이름은 ’no_warning’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-5. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n다음 코드를 사용해 보세요. \nlog(-3:3)\n모범 답안\n```{r no_warning, warning=FALSE}\nlog(-3:3)\n```\n실행 결과\n\n\nlog(-3:3)\n\n\n## [1]       NaN       NaN       NaN      -Inf 0.0000000 0.6931472\n## [7] 1.0986123\n\n\n\n1.6. 커맨트 변경하기\n\n앞의 튜토리얼 결과를 보면, 출련된 각 라인에 “##”가 앞에 출력되었습니다.\nlm(Sepal.Width ~ Sepal.Length, data = iris)를 실행하세요.\n“##”가 보기 싫습니다. 차라리 출력되지 않았으면 좋겠습니다.\n청크 이름은 ’change_comment’로 정의합니다.\n\n’understand_chunk.Rmd’의 1-6. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\ncomment 옵션을 사용합니다.\n모범 답안\n```{r change_comment, comment=\"\"}\nlm(Sepal.Width ~ Sepal.Length, data = iris)\n```\n실행 결과\n\n\nlm(Sepal.Width ~ Sepal.Length, data = iris)\n\n\n\nCall:\nlm(formula = Sepal.Width ~ Sepal.Length, data = iris)\n\nCoefficients:\n (Intercept)  Sepal.Length  \n     3.41895      -0.06188  \n\n\n\n2. 플롯 출력하기\n2.1. R 코드와 함께 플롯 출력하기\n\n다음 지문을 수행할, 분석 경험을 위해 코드와 결과를 공유할 청크를 만들려고 합니다.\niris 데이터에서 Sepal.Width ~ Sepal.Length 관계를 산점도로 시각화 하세요.\nSpecies별로 도형의 모양과 색상을 달리 그리세요.\nloess 산점도 위에 추세선도 출력하세요..\n\nR 코드와 결과를 함께 출력해 보세요.\n청크 이름은 ’scatter’로 정의합니다.\n\n’understand_chunk.Rmd’의 2-1. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n여러 방법이 있는데, 다음 코드를 사용해 보세요.\n\nlibrary(ggplot2)\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n모범 답안\n```{r scatter}\nlibrary(ggplot2)\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\nlibrary(ggplot2)\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n\n\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\n\n\n\n2.2. 플롯만 출력하기\n\n2.1. 결과에서 R 소스와 메시지의 출력 없이 플롯만 출력하려 합니다.\n청크 이름은 ’plot_only’로 정의합니다.\n\n’understand_chunk.Rmd’의 2-2. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\n여러 방법이 있는데, 다음 코드를 사용해 보세요.\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n모범 답안\n```{r plot_only, echo=FALSE, message=FALSE}\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\n\n\n\n2.3. 플롯 정렬하기\n\n2.2. 결과에서 플롯을 화면의 가운데 정렬로 출력하려 합니다.\n청크 이름은 ’plot_center’로 정의합니다.\n\n’understand_chunk.Rmd’의 2-3. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\nfig.align 인수를 사용합니다.\n모범 답안\n```{r plot_center, echo=FALSE, message=FALSE, fig.align=\"center\"}\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\n\n\n\n2.4. 플롯 화면출력 크기 조절하기\n\n2.3. 결과에서 플롯을 화면의 영역의 1/2 사이즈로 출력하려 합니다.\n청크 이름은 ’plot_half_width’로 정의합니다.\n\n’understand_chunk.Rmd’의 2-4. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\nout.width 인수를 사용합니다.\n모범 답안\n```{r plot_half_width, echo=FALSE, message=FALSE, fig.align=\"center\", out.width=\"50%\"}\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\n\n\n\n2.5. 플롯 출력에 캡션 넣기\n\n2.3. 결과에 캡션을 출력하려 합니다.\n“iris 품종별 산점도”라는 캡션을 추가합니다.\n청크 이름은 ’plot_caption’으로 정의합니다.\n\n’understand_chunk.Rmd’의 2-5. 빈 영역을 채우고 실행해 봅니다.\n모범 답안을 보지 않고 만들어 보세요.\n\n\n\n힌트 보기\nfig.cap 인수를 사용합니다.\n모범 답안\n```{r plot_caption, echo=FALSE, message=FALSE, fig.align=\"center\", fig.cap=\"iris 품종별 산점도\"}\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, \n                        color = Species, shape = Species)) +\n  geom_point() +\n  geom_smooth()\n```\n실행 결과\n\n\n\n(#fig:plot_caption)iris 품종별 산점도\n\n\n\n\n\n요약\n핸즈온 요약\nknitr 청크의 종류별로 다양한 출력 포맷의 문서를 작성했습니다.\nknitr 시각화 컨트롤 청크를 이용해서 플롯을 다양하게 출력했습니다.\nI can do it\nknitr의 대표적인 청크 옵션을 숙지해서, 화면에 분석 결과와 플롯 출력의 모양을 원하는대로 조정할 수 있습니다.\n\n\n\n",
      "last_modified": "2022-02-11T23:02:14+09:00"
    },
    {
      "path": "coding_style.html",
      "title": "R 코딩 스타일 가이드",
      "description": "패키지 개발에 앞서서, 중요하지만 간과하는 R 코딩 스타일을 살펴봅니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-03",
      "contents": "\n\nContents\nR 코딩 스타일\n중요한 R 코딩 스타일\n기타 중요한 규약\n객체 이름\n중괄호 내에서는 항상 들여 쓰기\n코드의 라인 길이는 80자 이내\n코드 들여쓰기(indentation)은 공백 2자로, 탭을 사용하지 않는다.\n할당 연산자의 선택\n주석의 생활화\n\n코딩 스타일 지원 패키지\nformatR\nlintr\n\n\n\n\n\n\n\n들어가기\n혼자면 충분합니다.\n\n둘이면 어쩌면 필요합니다.\n\n셋 이상이면 필수입니다. 뭐냐구요? 협업을 위해서 필요한 R 코딩 스타일 가이드입니다.\n\n\nR 코딩 스타일\n혼자서 패키지를 개발할 경우에는 문제가 덜하지만, 여럿이 협업해서 패키지를 개발할 경우에는 R 코딩 스타일이 이슈가 될 수 있습니다. 사람마다 서로 다른 코딩 스타일을 사용할 경우에는 코드의 일관성이 결여되고 협업에 어려움이 따르게 됩니다. 이 경우에는 서로 합일한 R 코딩 스타일 규칙을 따르는 것이 필요합니다. 굳이 협업이 아니더라도 잘 정의된 코딩 스타일을 고수할 필요 있습니다.\n\nGood coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read. – Hadley Wickham\n\nR 코딩 스타일은, 아주 오랜 전에 나온 Google의 R 스타일도 있지만, The tidyverse style guide를 준수하는 것을 권장합니다.\n중요한 R 코딩 스타일\nThe tidyverse style guide에 기술된 대표적인 코딩 스타일 컨벤션\n구분\n규약\nGood\nBad\n객체 이름\n소문자로 정의\nday_one, day_1\nDayOne, dayone\n객체 이름\n예약어나, 기정의 이름 불가\n\nT, mean\n공백\n컴마 뒤에 공백문자\nx[, 1]\nx[,1], x[ ,1]\n\n함수 호출 괄호 앞뒤에 공백문자 불가\nmean(x, na.rm = TRUE)\nmean (x, na.rm = TRUE)\n\n\n\nmean( x, na.rm = TRUE )\n\n괄호 뒤에 공백문자\nfunction(x) {}\nfunction (x) {}\n\n\n\nfunction(x){}\n\n연산자 앞 뒤에 공백문자\nheight <- (feet * 12) + inches\nheight<-feet*12+inches\n\n\nmean(x, na.rm = TRUE)\nmean(x, na.rm=TRUE)\n\n연산자 앞 뒤에 공백문자 불가\nsqrt(x^2 + y^2)\nsqrt(x ^ 2 + y ^ 2)\n\n\ndf$z\ndf $ z\n\n\nx <- 1:10\nx <- 1 : 10\n기타 중요한 규약\n객체 이름\n객체의 이름은 영문과 숫자, 그리고 문자 \"_\"으로 정의합니다. 그리고, 간결하지만, 의미를 충분히 전달해야 합니다.\n변수는 명사를 사용하고,\n예) item, score\n\n함수는 동사를 사용하고\n예) edit_table, print\n\n중괄호 내에서는 항상 들여 쓰기\n\n\n# Good\nif (y < 0 && debug) {\n  message(\"y is negative\")\n}\n\n# Bad\nif (y < 0 && debug) {\nmessage(\"Y is negative\")\n}\n\n\n\n코드의 라인 길이는 80자 이내\n코드의 라인 길이는 80자 이내로 관리합니다. Rstudio의 Global Options… > Code > Display 메뉴에서 Show margin을 체크하면, 에디터에 기준선이 80자를 표현해서 80자 이내로 관리하는데 유용합니다.\n\n\n\n코드 들여쓰기(indentation)은 공백 2자로, 탭을 사용하지 않는다.\n코드의 들여쓰기는 공백 2로 설정합니다. Rstudio의 Global Options… > Code > Edit 메뉴에서 Insert spaces for tab을 체크한 후, 탭을 공백 2개로 설정하면 유용합니다. 공백의 개수는 2개, 4개 등 호불호가 있기는 합니다만 개인적으로 2개를 추천합니다.\n\n\n\n할당 연산자의 선택\n이름에 객체를 할당할 때에는 <- 연산자를 사용\n예) average <- mean(x, na.rm = TRUE)\n\n함수에서 인수에 인수값을 할당할 때에는 =를 사용\n예) edit_table, print\n\n주석의 생활화\n주요 로직이나, 공유해야할 사항, 남겨야할 정보 등을 반드시 주석으로 남겨야 합니다.\n코딩 스타일 지원 패키지\n이 장에서는 tidyverse R 코딩 스타일 가이드에 어느 정도 부합하는 몇 가지 R 패키지를 소개합니다. 그리고 이들 패키지로 사용자가 작성한 소스가 R 코딩 스타일에 부합하는지의 여부를 점검하거나, 패키지에서 추천하는 코딩 스타일로 소스를 변경해주는 방법을 알아봅니다.\n\n이들 패키지가 100% 완전한 코딩 스타일을 준수하는 코드로 바꿔주거나 제언해주지 않음을 염두에 두어야 합니다.\n\nformatR\nformatR 패키지는 R 코드의 포맷을 자동으로 바꿔주는 기능을 수행하는 패키지입니다. 이 패키지를 사용하여 작성한 R 코드를 스타일 가이드에 의거하여 적절하게 바꿔주는 방법을 살펴봅니다.\n예제는 패키지의 R 소스 코드를 담고 있는 “R” 디렉토리 내의 misc.R 파일에 getMonthLenth() 함수 정의 코드가 들어 있음을 가정합니다.\nR/misc.R 파일의 getMonthLenth() 함수를 정의하는 코드는 다음과 같습니다.\n\n\ngetMonthLenth <- function(startYear, startMonth, endYear, endMonth) {\n    ifelse(startMonth > endMonth,\n         12 + endMonth - startMonth + (endYear - startYear - 1) * 12 + 1,\n         endMonth - startMonth + (endYear - startYear) * 12 + 1)\n}\n\n\n\nformatR 패키지의 tidy_file() 함수는 지정한 파일에 대해서 R 코드의 포맷을 자동으로 바꿔주고, tidy_dir() 함수는 지정한 디렉토리에 포함된 R 파일에 대해서 코드 포맷을 보정해 줍니다.\n다음은 패키지의 R 소스 코드에 대해서 포맷을 보정해 주는 명령어입니다.\n\n> formatR::tidy_dir(\"R\", indent = 2, width.cutoff = 60)\ntidying R/misc.R\n\n상기 코드가 실행되면 R/misc.R 파일의 getMonthLenth() 함수를 정의하는 코드는 다음과 같이 보정됩니다. indent 인수의 값이 2인것은 들여쓰기를 스페이스 2개로 지정한 것이고, width.cutoff 인수는 할 줄에 표현하는 코드의 길이를 60 character로 지정한다는 의미입니다.\n\n\ngetMonthLenth <- function(startyear, startmonth, endyear, endmonth) {\n  ifelse(startmonth > endmonth, 12 + endmonth - startmonth + \n    (endyear - startyear - 1) * 12 + 1, endmonth - startmonth + \n    (endyear - startyear) * 12 + 1)\n}\n\n\n\nlintr\nlintr 패키지는 R 코딩 스타일 부합 여부를 점검해줍니다. R 코드를 변경하지 않고 점검만 해주는 점이 formatR 패키지와의 차이점입니다. 그러나 lintr 패키지의 점검 내용은 포맷보다는 코딩 스타일에 가깝습니다. 예를 들면 변수의 이름은 소문자로 사용하는 것, 할당 연산자를 = 대신에 <-를 사용하는 것 등의 암묵적인 R 코딩 스타일의 준수 여부를 체크합니다.\nlint_file() 함수는 지정하는 R 파일에 대해서 R 코딩 스타일의 준수 여부를 체크하고, lint_package() 함수는 패키지 내의 R 파일에 대해서 R 코딩 스타일의 준수 여부를 체크합니다.\n다음은 패키지의 R 소스 코드에 대해서 R 코딩 스타일의 준수 여부를 체크합니다. RStudio 상에서의 결과는 아래의 그림처럼 Markers 탭에 표현되며, 체크에서 미준수 항목으로 출력된 개별 라인을 클릭하면, 소스 파일의 해당 위치로 커서가 옮겨집니다.\n\n> lintr::lint_package()\n\n\n\n\n체크에서 미준수 항목으로 출력된 개별 라인을 수정한 후 lint_package() 함수를 재 실행하면서 코드를 수정하면 R 코딩 스타일에 부합하는 코드를 작성할 수 있습니다.\n미준수 항목으로 출력된 개별 라인을 수정하여, getMonthLenth() 함수를 다음과 같이 재작성하였습니다.\n\n\nget_month_length <- function(startyear, startmonth, endyear, endmonth) {\n  ifelse(startmonth > endmonth, 12 + endmonth - startmonth +\n    (endyear - startyear - 1) * 12 + 1, endmonth - startmonth +\n    (endyear - startyear) * 12 + 1)\n}\n\n\n\n\n\n\n",
      "last_modified": "2022-02-11T23:02:15+09:00"
    },
    {
      "path": "control-widget.html",
      "title": "위젯 추가하기",
      "description": "위젯을 이해합니다. **입력 위젯**을 패널에 추가하는 방법을 숙지해야 합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-05",
      "contents": "\n\nContents\n위젯을 아시나요?\n입력 위젯\n\n위젯을 추가한 예제\ntutorial\n입력 위젯 완성하기 tutorial\nShiny 공식 tutorial 페이지\n추가 예제 실행해 보기\n\n\n\n\n\n\n\n들어가기\n위젯은\n메신저의 눈과 귀\n입니다.\n의도 파악을 위한 듣는 위젯\n과\n내용의 전달을 위한 말하는 위젯\n으로 구성됩니다.\n\n위젯의 기능과 사용방법을 익히는 것은 말을 익히는 것과 유사합니다. 당신은 문법을 익히고, 어휘를 늘려가야 합니다. 관용어구를 하나 더 익혀야할 수도 있습니다.\n\n\n위젯을 아시나요?\n“위젯(widget)은 컴퓨터 프로그래밍에서 위젯(widget) 또는 컨트롤(control)은 컴퓨터 사용자가 상호 작용하는 인터페이스 요소입니다.” - https://ko.wikipedia.org/wiki/GUI_위젯 중에서\n입력 위젯\nShiny에서는 입력 위젯을 컨트롯 위젯(control widgets)이라 부릅니다. 즉, 위젯을 통해서 앱을 컨트롤하기 때문입니다. 굳이 입력 위젯이라고 불렀던 것은 입력된 값을 통해서 기능이 컨트롤되고, 중요한 대부분 컨트롤 위젯 이름의 접미사가 “Input”이기 때문입니다.\nshiny 패키지의 입력 위젯은 버튼을 포함해서 다음과 같은 종류가 있습니다.\n\n\nlibrary(shiny)\n\nsetdiff(union(ls(pos = \"package:shiny\", pattern = \"Input$\"), \n      ls(pos = \"package:shiny\", pattern = \"Button$\")),\n      ls(pos = \"package:shiny\", pattern = \"^update\"))\n\n\n [1] \"checkboxGroupInput\"      \"checkboxInput\"          \n [3] \"dateInput\"               \"dateRangeInput\"         \n [5] \"fileInput\"               \"numericInput\"           \n [7] \"passwordInput\"           \"restoreInput\"           \n [9] \"selectInput\"             \"selectizeInput\"         \n[11] \"sliderInput\"             \"snapshotPreprocessInput\"\n[13] \"textAreaInput\"           \"textInput\"              \n[15] \"varSelectInput\"          \"varSelectizeInput\"      \n[17] \"actionButton\"            \"bookmarkButton\"         \n[19] \"downloadButton\"          \"modalButton\"            \n[21] \"submitButton\"           \n\n기본 입력 위젯은 다음 그림과 같습니다.\n기본 입력 위젯위젯을 추가한 예제\n다음 예제는 레이아웃과 패널에 입력 위젯을 출력한 예제입니다.\n\n\nui <- fluidPage(\n  titlePanel(\"censusVis\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Create demographic maps with \n               information from the 2010 US Census.\"),\n      \n      selectInput(\"var\", \n                  label = \"Choose a variable to display\",\n                  choices = list(\"Percent White\", \n                                 \"Percent Black\",\n                                 \"Percent Hispanic\", \n                                 \"Percent Asian\"),\n                  selected = \"Percent White\"),\n      \n      sliderInput(\"range\", \n                  label = \"Range of interest:\",\n                  min = 0, max = 100, value = c(0, 100))\n    ),\n    \n    mainPanel()\n  )\n)\n\n\n\n위의 예제의 결과는 다음과 같습니다.\n입력 위젯들그리고 위 그림에서 selectInput은 이름처럼 여러 값 중에서 하나의 값을 선택하는 입력 위젯입니다. 다음처럼 마우스를 올려 놓으면 네 개의 값이 출력되고, 사용자는 하나의 값을 선택하면 됩니다.\nselectInput 위젯tutorial\n입력 위젯 완성하기 tutorial\n다음 코드를 입력한 후, app.R이라는 이름의 파일로 저장하고 실행해 보세요. 완성된 입력 위젯의 기능을 확인할 수 있습니다. 여러분은 UI 파트를 완성하였습니다.\n\n\nlibrary(shiny)\n\n# Define UI ----\nui <- fluidPage(\n  titlePanel(\"censusVis\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Create demographic maps with \n               information from the 2010 US Census.\"),\n      \n      selectInput(\"var\", \n                  label = \"Choose a variable to display\",\n                  choices = list(\"Percent White\", \n                                 \"Percent Black\",\n                                 \"Percent Hispanic\", \n                                 \"Percent Asian\"),\n                  selected = \"Percent White\"),\n      \n      sliderInput(\"range\", \n                  label = \"Range of interest:\",\n                  min = 0, max = 100, value = c(0, 100))\n    ),\n    \n    mainPanel()\n  )\n)\n\n# Define server logic ----\nserver <- function(input, output) {\n  \n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)\n\n\n\nShiny 공식 tutorial 페이지\nShiny 공식 tutorial 페이지를 살펴보고, 입력 위젯의 종류와 설정하는 방법을 이해하세요.\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson3/\n추가 예제 실행해 보기\n예제를 실행시켜 보고, 다양한 입력 위젯과 출력 위젯을 경험해 보세요.\n\n\nshiny::runExample(\"07_widgets\")\n\n\n\n\n\n\n",
      "last_modified": "2022-02-11T23:02:16+09:00"
    },
    {
      "path": "custom_docker.html",
      "title": "docker 컨테이너 환경 설정하기",
      "description": "docker 기반으로 Shiny 서버를 운영하기 위한 컨테이너 환경설정을 수행합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2022-01-16",
      "contents": "\n\nContents\ndocker 컨테이너 환경 설정하기\nShiny 서버 환경 설정하기\n포트와 볼륨 설정\nDocker Desktop 활용\n콘솔 명령어 사용\n\nBitStat 애플리케이션 실행\n결언\n\n\n\n\n삽화출처: 초보를 위한 도커 안내서 - 도커란 무엇인가?\n\n\n들어가기\n컨테이너 환경설정이라 말하고 실행만 합니다. \n\ndocker 컨테이너를 실행하는 옵션을 GUI 화면에서 어렵게 시도합니다.\n\nCLI에서는 간단한 것을? 그러나 전문가가 아니니까요. Docker Desktop을 애용한답니다.\n\n\n\ndocker 컨테이너 환경 설정하기\n우리는 Shiny 데모 애플리케이션을 실행하기 위해서 Shiny 서버를 설치하지는 않을 것입니다. Shiny 데모 애플리케이션이 구동되는 최소 환경은 “아 Shiny 애플리케이션이 서버가 docker 환경에서 실행되는 구나” 정도를 인지할 뿐, 사용자가 개발한 애플리케이션을 운영하기 위해서는 몇가지 작업을 수행해야 합니다.\n우리는 오픈통계 패키지인 BitStat를 Shiny 서버에서 운영하는 것을 전제로 Shiny 서버의 docker 환경을 설정할 것입니다.\ndocker를 업무에, 혹은 자주 사용하지 않는 관계로 docker에 정통하지는 않습니다. 아주 기본적인 지식만 가지고 있을 뿐이죠. (명령어를 줄줄이 외울 정도로 잦은 주기의 docker 작업을 수행하지 않기 때문에) 그래서 개인적으로 Mac OS에서 Docker Desktop라는 Docker 관리 애플리케이션을 사용하고 있습니다. 이 글은 Docker Desktop을 이용하는 방법을 위주로 작성합니다. 하지만 docker 명령어도 간간히 병기하여 설명하도록 합니다.\nShiny 서버 환경 설정하기\nShiny 서버에서 BitStat 애플리케이션을 운영하기 위해서는 다음과 같은 추가적인 환경설정 작업이 필요합니다.\n애플리케이션을 배포할 경로 설정\nBitStat 애플리케이션이 위치할 경로 설정\n\n애플리케이션 수행시 발생하는 로그 경로 설정\n애플리케이션 운영의 안정성을 위한 Shiny 서버 로그\n\n애플리케이션이 실행에 필요한 R 패키지 설치\nrocker/shiny-verse 이미지에 누락된 R 패키지 설치\n\n포트와 볼륨 설정\nrocker/shiny-verse 이미지에는 BitStat 애플리케이션이 포함되어 있지 않습니다. 그러므로 BitStat 애플리케이션을 docker 컨테이너에 호스트의 볼륨(Volumes)으로 탑재해야 합니다.\n그리고 docker 컨테이너 안에서의 수행하는 Shiny 애플리케이션의 로그를 호스트에서도 확인하기 위해서 로그를 쌓을 볼륨도 설정해야 합니다. 특히 모든 리소스들이 정확하게 설치되어 문제없이 애플리케이션이 실행되기 전까지는 이 로그의 역할이 매우 중요합니다. 트러블슈팅(Troubleshooting)의 실마리를 제공해주는 유일한 환경이기 때문입니다.\nShiny 서버는 3838 포트를 사용합니다. 여기서도 Shiny 서버의 기본 포트인 3838을 사용합니다.\nDocker Desktop 활용\nDocker Desktop의 이미지 목록의 ‘NAME’ 컬럼에 ’rocker/shiny-verse’이 리스트업 되었습니다.\nDocker Desktop의 이미지 목록포트와 볼륨 설정을 위해서 ‘RUN 버튼’을 눌러서 컨테이너 정의 다이얼로그를 엽니다. 그러면 다음과 같은 ‘New Container’ 다이얼로그가 나타납니다. 이 화면에서 바로 ’Run 버튼’누르지 말고 ‘Optional Settings’를 선택합니다.\nDocker Desktop의 이미지 목록이 Optional Settings 다이얼로그 창에서 다음처럼 포트와 볼륨설정을 정의합니다.\ndocker hub 사이트의 rocker/shiny 페이지를 참고하여 옵션을 설정합니다.\nContainer Name: shiny-server\nPorts:\nLocal Host: 3838\nContainer Port: default\n\nBitStat 애플리케이션 Path\nHost Path: BitStat 애플리케이션이 있는 호스트 경로\nContainer Path: /srv/shiny-server\n\nBitStat 애플리케이션 Path\nHost Path: Shiny 서버 로그를 저장할 호스트 경로\nContainer Path: /var/log/shiny-server\n\n설정한 후 ’Run 버튼’을 누르면 Shiny 서버 컨테이너가 실행됩니다.\nOptional Settings 다이얼로그 창이미지 목록 화면에서 ’rocker/shiny-verse’의 ‘INUSE’ 버튼을 누릅니다.\nOptional Settings 다이얼로그 창그러면 다음처럼 ‘rocker/shiny-verse’ 이미지에서 실행된 컨테이너 목록을 확인할 수 있습니다. 목록을 보면 ‘shiny-server’라는 이름의 컨테이너가 3838 포트로 실행중임을 알 수 있습니다.\nOptional Settings 다이얼로그 창콘솔 명령어 사용\nDocker Desktop을 사용하지 않는다면, 다음의 명령어로도 간단하게 ‘rocker/shiny’ 이미지를 실행할 수 있습니다.\n\ndocker run -d -p 3838:3838 --name shiny-server \\\n    -v /Users/choonghyunryu/shiny-server/:/srv/shiny-server/ \\\n    -v /Users/choonghyunryu/Documents/99_logs/shiny/:/var/log/shiny-server/ \\\n    rocker/shiny\n\nBitStat 애플리케이션 실행\n이제는 http://localhost:3838 URL로 Shiny 서버 데모가 실행되지 않습니다. Shiny 서버의 홈 디렉토리 호스트의 경로로 변경했기 때문입니다. 이제는 이 URL은 다음과 같은 화면을 출력합니다.\n로컬 호스트의 /Users/choonghyunryu/shiny-server/ 디렉토리에는 서브 디렉토리로 BitStat 애플리케이션이 위치하기 때문입니다.\nShiny 서버 홈디렉토리 애플리케이션화면에서 BitStat 링크를 클릭하거나 http://localhost:3838/BitStat/ URL로 BitStat 애플리케이션을 실행할 수 있습니다.\n그러나 다음처럼 에러가 발생했습니다.\n오류가 발생한 BiStat 애플리케이션에러가 발생한 원인을 호스트의 로그 볼륨에서 확인할 수 있습니다. 호스트의 /Users/choonghyunryu/Documents/99_logs/shiny 디렉토리에 있는 로그 파일을 열어봅니다.\nBiStat 애플리케이션 로그 파일docker 컨테이너에 shinyjs 패키지가 설치되어 있지 않았기 때문에 에러가 발생한 것입니다. ‘rocker/shiny-verse’ 이미지에는 이 패키지가 포함되어 있지 않기 때문입니다.\n결언\ndocker 컨테이너에 호스트의 애플리케이션 경로와 로그 경로를 연결하고, 포트를 설정했습니다. 그러나 ‘rocker/shiny-verse’ 이미지에 필요한 R 패키지가 없어서 서비스가 정상적으로 구동되지 않았습니다.\n컨테이너 안에 필요한 R 패키지를 설치해야 합니다.\n\n\n\n",
      "last_modified": "2022-02-11T23:02:17+09:00"
    },
    {
      "path": "custom_image.html",
      "title": "docker 이미지 만들기",
      "description": "Shiny 애플리케이션에 필요로 하는 R 패키지를 추가로 설치하여 새로운 docker 이미지를 생성합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2022-01-22",
      "contents": "\n\nContents\nDockerfile 만들기\n명령어의 이해\nBitStat를 운영하기 위한 Dockerfile 파일\n베이스 이미지 가져오기\n개발 라이브러리 설치하기\nR 패키지 설치하기\n포트지정\n사용자 전환\n\ndocker 이미지 생성\n크롬을 위한 설정\ndocker 이미지 생성\n\n컨테이너 생성 및 실행\n기존 컨테이너와 이미지 삭제\n컨테이너 생성 및 실행\n\nBitStat 애플리케이션 실행\n결언\n\n\n\n\n삽화출처: Implementing Embedded Continuous Integration with Jenkins and Docker: Part1\n\n\n들어가기\ndocker의 꽃은 Dockerfile입니다.\n\nDockerfile로 BisStat를 비롯한 몇개의 Shiny 애플리케이션을 실행할 수 있는 환경을 커스트마이징합니다.\n\ndocker 꽃이 활짝 피겠군요.\n\n\n\nDockerfile 만들기\n이제 완전하게 Shiny 애플리케이션이 운용될 docker 컨테이너를 만들고 실행할 차례입니다.\nMakefile이 C/C++로 개발된 소스를 컴파일하고 배포하는 make의 룰을 정의한 파일이라면, Dockerfile은 docker 이미지를 생성하는 방법을 정의한 파일입니다. Dockerfile을 이용하면, 컨테이너 내부에 유틸리티, 개발 라이브러리나 R 패키지를 설치할 수 있습니다. 즉 rocker/shiny-verse 이미지에서 지원하지 못했던, 애플리케이션을 실행시키는데 필요한 패키지를 설치할 수 있습니다.\n명령어의 이해\nDockerfile에 사용하는 대표적인 명령어는 다음과 같습니다.\nFROM\n베이스(base) 이미지를 가져옵니다.\n\nRUN\n설치된 베이스 이미지 파일시스템의 운영체제에서 쉘 스크립트(shell script)를 실행합니다.\n\nCOPY\n호스트에 있는 디렉토리나 파일을 docker 이미지 파일 시스템으로 복사합니다.\n\nEXPOSE\n컨테이너로 들어오는 트래픽을 리스닝할 프로토콜과 포트를 설정합니다.\n\nUSER\n명령어를 수행할 사용자 계정을 지정합니다.\nUSER 명령어 이후부터 적용되며, 이미 생성된 계정이어야 합니다.\n\nBitStat를 운영하기 위한 Dockerfile 파일\n다음과 같은 내용의 Dockerfile 파일을 작성합니다. 의외로 설치하는 R 패키지가 많은 이유는, BitStat뿐만 아니라 개인적으로 만든 여러 개의 Shiny 애플리케이션을 이 환경에서 구동하기 위함입니다.\n\nFROM rocker/shiny:latest\n\n# system libraries of general use\nRUN apt-get update && apt-get install -y \\\n    libxml2-dev \\\n    libcairo2-dev \\\n    libsqlite3-dev \\\n    openjdk-11-jdk \\\n    liblzma-dev \\\n    libbz2-dev \\\n    libssl-dev \\\n    curl\n\nRUN curl -L http://bit.ly/google-chrome-stable -o google-chrome-stable.deb && \\\n    apt-get -y install ./google-chrome-stable.deb && \\\n    rm google-chrome-stable.deb\n\n# install R packages required\nRUN R -e \"install.packages('rJava',              repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('dlookr',             repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('shinyjs',            repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('shinydashboard',     repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('shinydashboardPlus', repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('shinyWidgets',       repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('shinybusy',          repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('shinythemes',        repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('shinycssloaders',    repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('colourpicker',       repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('htmltools',          repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('htmltools',          repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('reactable',          repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('glue',               repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('xlsx',               repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('flextable',          repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('googleVis',          repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('readr',              repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('forcats',            repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('plotly',             repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('DBI',                repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('waffle',             repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('RSQLite',            repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('remotes',            repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('dbplyr',             repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('ggthemes',           repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('treemapify',         repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('sparkline',          repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('formattable',        repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('DT',                 repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"install.packages('tidyverse',          repos = 'http://cran.rstudio.com/')\"\nRUN R -e \"remotes::install_github('dreamRs/shinytreeview')\"\n\nCOPY google-chrome /usr/local/bin/\n\nUSER shiny  \nCOPY Renviron /.Renviron\n\n베이스 이미지 가져오기\n다음 FROM 명령어는 docker hub에서 ‘rocker/shiny’ 이미지의 최신 버전(lasett)을 가져오라는 의미입니디. 이 이미지를 베이스 이미지로 사용할 것입니다. 이미 앞에서 사용했던 이미지입니다.\n\nFROM rocker/shiny:latest\n\n개발 라이브러리 설치하기\n다음 RUN 명령어는 컨테이너 안의 파일시스템에서 Shell 명령어를 수행하라는 의미입니다.\napt-get(Advanced Packaging Tool)은 우분투(Ubuntu)를 포함한 데이안(Debian) 계열의 리눅스 배포본에서의 시스템 패키지 관리 유틸리티입니다. 이 유틸리티로 개발 라이브러리나 시스템 유틸리티를 설치합니다.\n다수의 R 패키지는 시스템 유틸리티나 동적 라이브러리를 인터페이스하여 구현합니다. 예를 들면 RSQLite라는 R 패키지는 sqlite3의 동적 라이브러리를 사용합니다. 그래서 R 환경에서 sqlite를 사용하는 RSQLite 패키지는 개발 라이브러이인 libsqlite3-dev을 설치해야 합니다.\nR 패키지에서 설치하기 까다로운 rJava 패키지는 JVM(Java Virtual Machine)을 인터페이스하기 위해서 JDK를 설치해야 합니다. 이를 위해서 JDK 11 버전인 openjdk-11-jdk를 설치합니다.\n그리고 인터넷을 통해 공유하는 파일을 가져오기 위해서는 curl이 필요할지도 모릅니다.\n이를 위해서 ‘apt-get update && apt-get install -y’ 명령어 구문으로 개발 라이브러리와 시스템 유틸리티를 설치합니다.\n\n# system libraries of general use\nRUN apt-get update && apt-get install -y \\\n    libxml2-dev \\\n    libcairo2-dev \\\n    libsqlite3-dev \\\n    openjdk-11-jdk \\\n    liblzma-dev \\\n    libbz2-dev \\\n    libssl-dev \\\n    curl\n\n\n\n\n\n크롬(Chorme) 설치\n\nBitStat는 pdf 보고서를 생성하기 위해서 pagedown 패키지를 사용합니다. 그런데 이 패키지는 크롬(Chrome)을 이용해서 웹 페이지를 pdf 파일로 변환합니다.\n\n그래서 컨테이너에 리눅스용 크롬 브라우저를 설치해야 합니다.\n\n\n\n다음처럼 curl을 이용해서 크롬을 다운로드한 후 설치하고 삭제합니다. 이를 위해서 앞에서 apt-get로 curl을 설치한 것입니다.\n\nRUN curl -L http://bit.ly/google-chrome-stable -o google-chrome-stable.deb && \\\n    apt-get -y install ./google-chrome-stable.deb && \\\n    rm google-chrome-stable.deb\n\nR 패키지 설치하기\n다음 RUN 명령어는 R 유틸리티로 R 패키지를 설치합니다. -e 옵션은 R이 수행할 R 스크립트를 지정하는 옵션입니다. 따옴표 안의 R 스크립트로 패키지를 설치하게 됩니다.\n\nRUN R -e \"install.packages('rJava', repos = 'http://cran.rstudio.com/')\"\n\n포트지정\n컨테이너가 사용할 포트를 지정하기 위해서 EXPOSE 명령어를 사용하지 않아도 됩니다. 베이스 이미지로 ’rocker/shiny’를 사용했기 때문입니다. 이 베이스 이미지에 이미 EXPOSE 명령어로 3838 포트를 컨테이너가 사용할 수 있도록 설정되어 있기 때문입니다.\n사용자 전환\nroot 권한으로 컨테이너를 실행하면, 무제한의 권한이 부여되므로, 보안 측면에서 취약할 수 있습니다. 그래서 다음처럼 일반 사용자인 shiny 사용자 계정으로 컨테이너를 실행하도록 설정합니다.\n이지 베이스 이미지인 rocker/shiny-verse에서 shiny라는 그룹과 사용자를 만들어 놓았기 때문에 해당 사용자 계정을 만들 필요는 없습니다.\n\nUSER shiny\n\ndocker 이미지 생성\n크롬을 위한 설정\npagedown 패키지가 크롬을 사용한다는 것을 앞에서 언급했습니다. 그런데 pagedown::chrome_print()가 크롬을 호출할 때, 다음처럼 “Error in is_remote_protocol_ok: Cannot find headless Chrome after 20 attempts”라는 에러가 발생합니다.\n\noutput file: diagnosis_paged_temp.knit.md\n\n\nOutput created: diagnosis_paged_temp.html\nWarning: Error in is_remote_protocol_ok: Cannot find headless Chrome after 20 attempts\n  1: runApp\n\nExecution halted\n\n크롬은 ‘샌드박스(sandbox)’라는 보안 개념을 적용합니다. 크롬은 브라우저에서 여러 개의 독립된 탭을 띄우고, 별도의 웹 페이지가 실행됩니다. 별도로 독립된 프로세스가 가동하는 것으로 이들 프로세스는 샌드박스처럼 격리되어서 서로 관여하지 못합니다. 즉, 어느 탭의 웹 페이지에서 악성코드가 침투하거나, 버그 또는 장애로 해당 탭의 페이지가 먹통되어도 다른 탭의 웹 페이지는 정상적으로 동작합니다.\n앞에서의 에러는 크롬의 샌드박스 기능에 기인합니다. 이 에러는 해결하기 위해서는 컨테이너에서 pagedown::chrome_print()가 크롬을 호출할 때, 샌드박스의 기능을 비활성해야 합니다.\n이를 위한 몇 가지 솔루션이 있습니다.\n\npagedown::chrome_print() 함수 호출 수정\nextra_args 인수값에 c(“–no-sandbox”)를 기술하여 호출\ndlookr 패키지를 수정해야 함\n크롬 실행 시 옵션 정의\n–no-sandbox 옵션 추가\n\n여기서는 2번 솔루션을 적용합니다.\n다음과 같은 스크립트를 담은 google-chrome 파일을 ./shiny-docker 경로에 생성합니다.\n\n#!/bin/bash\n\n/usr/bin/google-chrome --no-sandbox $*\n\n그리고 호스트에서 이 파일의 권한을 설정합니다. shiny 계정으로 컨테이너를 실행하기 때문에 755 권한을 부여해야 합니다.\n\nchmod 755 google-chrome\n\n다음으로 다음과 같은 스크립트를 담은 Renviron 파일을 ./shiny-docker 경로에 생성합니다.\n\n\nPATH=\"/:${PATH}\"\n\n\n\n그리고 Dockerfile 파일에서 이들을 다음처럼 컨테이너에 복사합니다.\n\nCOPY google-chrome /usr/local/bin/\nCOPY Renviron /.Renviron\n\ndocker 이미지 생성\n앞에서 만든 Dockerfile는 ./shiny-docker 경로에 저장했습니다. 이 Dockerfile을 빌드해서 docker 이미지를 생성합니다.\nbuild 명령어로 이미지를 생성합니다. -t 옵션은 생성할 이미지의 이름을 지정합니다. 이미지 이름을 ’shiny’로 지정했습니다.\n\ndocker build -t shiny:first ./shiny-docker\n\n컨테이너 생성 및 실행\n기존 컨테이너와 이미지 삭제\n이제 앞에서 만들었던 ‘rocker/shiny-verse’ 이미지와 ‘shiny-server’ 컨테이너는 필요가 없어졌습니다. 그래서 다음처럼 컨테이너와 이미지를 차례대로 삭제합니다.\n\ndocker rm -f shiny-server\ndocker rmi rocker/shiny-verse\n\n컨테이너 생성 및 실행\n이번에는 Docker Desktop를 이용해서 컨테이너를 생성하고 실행합니다. 다음은 Optional Settings 다이얼로그 창에서의 환경설정 내용입니다.\nContainer Name: shiny-server\nPorts:\nLocal Host: 3838\nContainer Port: default\n\nBitStat 애플리케이션 Path\nHost Path: BitStat 애플리케이션이 있는 호스트 경로\nContainer Path: /srv/shiny-server\n\nBitStat 애플리케이션 Path\nHost Path: Shiny 서버 로그를 저장할 호스트 경로\nContainer Path: /var/log/shiny-server\n\nOptional Settings 다이얼로그 창다음 명령도로 동일한 기능을 수행합니다. –name 옵션은 컨테이너의 이름을 지정합니다. -p, -v는 각각 포트와 볼륨을 정의합니다.\n\ndocker run -d -p 3838:3838 --name shiny-server \\\n    -v /Users/choonghyunryu/shiny-server/:/srv/shiny-server/ \\\n    -v /Users/choonghyunryu/Documents/99_logs/shiny/:/var/log/shiny-server/ \\\n    shiny:first\n\n컨테이너를 실행한 후 콘솔로 들어가서 프로세스를 확인하면, 다음처럼 shiny 계정으로 shiny 서버 프로세스가 실행되었음을 확인할 수 있습니다.\n프로세스 현황BitStat 애플리케이션 실행\n이제는 http://localhost:3838/BitStat/ URL로 BitStat 애플리케이션을 실행할 수 있습니다.\n실행된 BitStat 애플리케이션 화면은 다음과 같습니다.\nBiStat 애플리케이션결언\n이제 docker 환경에서 BitStat 애플리케이션을 실행할 수 있습니다. 추가로 개발하는 Shiny 애플리케이션은 앞에서 정의한 로컬 호스트의 /Users/choonghyunryu/shiny-server/ 디렉토리에 배포하면 됩니다.\n어느 정도 목적하는 환경의 Shiny 서버를 구동하려면, 결국은 docker 이미지를 만들어야할 수 밖에 없습니다. 개인적으로 Shiny 애플리케이션의 데모 환경을 만들려는 목적으로 시도한 작업입니다만, docker의 매력을 느끼기에 충분했습니다.\nR과 Shiny를 사용하기에는 MS-Windows 환경이 부족함이 없지 않습니다. 여러 사람들과 협업을 하기 위해서는 동일한 환경에서의 작업이 중요합니다. 이런 대안으로 docker 환경에서 R과 Shiny를 사용하는 것이 유용한 대안이 될 것 같습니다.\n\n\n\n",
      "last_modified": "2022-02-11T23:02:18+09:00"
    },
    {
      "path": "develop_package.html",
      "title": "R 패키지 개발하기",
      "description": "몇 가지 Open API를 이용한 데이터 수집 기능을 구현한 R 패키지를 만들어 봅니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-05",
      "contents": "\n\nContents\nR 패키지 시나리오\nR 패키지의 구성\n패키지 구성 파일\n파일이름 명명규칙\n\nR 패키지 골격 만들기\nR 패키지 골격 살펴보기\nR 패키지 개발하기\nDESCRIPTION 파일 수정하기\n소스파일 만들기\n\n패키지 관련 파일의 자동 생성\nroxygen2\nroxygen2 태그\nroxygen2 태그 기반 자동 생성\n\nR 데이터 생성\nR 데이터 파일 생성\nR 데이터 도움말 파일 생성\n\nvignette 작성하기\nvignette 골격 생성하기\nvignette 작성하기\nvignette 빌드하기\n\n개발자의 koscrap 패키지 설치하기\nR 패키지 설치하기\n\nkoscrap 패키지 사용하기\n사용자의 koscrap 패키지 설치하기\ndevtools 패키지 설치\nkoscrap 패키지 설치\n\n\n\n\n\n\n\n들어가기\n패키지, 그 범접할 수 없는 아우라!!!\n\n그러나 사실 어렵지 않게 만들 수 있습니다.\n\n시도를 해 보지 않아서 어렵게 느낄뿐 한번 만들고 보면, 이내 두번째 패키지를 만들고 있을 겁니다.\n\n\nR 패키지 시나리오\n앞에서 네이버 오픈 API를 이용해서 뉴스를 검색하는 함수와 공공데이터포털의 오픈 API를 이용해서 아파트 실거래 상세 정보를 조회하는 함수를 만들어 보았니다.\n이제 이들 함수를 포함한 R 패키지를 만들어 보려 합니다. 다음의 내용을 담을 계획입니다.\n함수\n네이버 오픈 API를 이용한, 뉴스 검색 함수\n공공데이터포털의 오픈 API를 이용한, 아파트 실거래 상세 정보 조회 함수\n\n데이터\n법정동 코드 데이터\n\n소품(Vignettes)1\n두 함수를 사용하는 방법을 소개한 비네트\n\nR 패키지의 구성\n패키지 구성 파일\nDESCRIPTION\n패키지의 기본적인 정보를 담고 있는 메타 파일로 패키지의 버전, 저자, 종속성 등이 담겨 있습니다. CRAN의 R 패키지 페이지에서는 패키지의 여러 정보를 제공하는데, 대부분이 DESCRIPTION의 정보로 표현합니다.\nNAMESPACE\n개발하는 패키지가 참조하는 다른 패키지의 객체(함수나 메소드 등), 개발하는 패키지가 제공하는 객체를 네임스페이스에 등록하기 위한 정보를 담습니다.\n소스\nR 디렉토리에 프로그램 소스 파일을 담는다. *.R 형식으로 이름을 정의합니다.\n도움말\nman 디렉토리에 데이터나 함수, 메소드에 대한 도움말 파일을 담는다. *.Rd 형식으로 이름을 정의합니다.\n소품(vignettes)\nvignettes 디렉토리에 도움말 보다 좀 더 친절한 패키지 사용 방법을 소개하는 소품 파일을 담습니다. R 마크다운 편집 파일로 *.Rmd 형식으로 이름을 정의합니다.\n데이터\ndata 디렉토리에 R 데이터 파일을 담습니다. R 데이터 파일로 *.rda 형식으로 이름을 정의합니다.\n기타 제공 파일\ninst 디렉토리에 패키지를 구성하는 표준 파일이 아니지만 패키지에 제공할 파일을 넣을 수 있습니다.\n파일이름 명명규칙\nDESCRIPTION, NAMESPACE 파일 이름은 변경이 불가능합니다. 소스파일과 소품 파일은 이름으로도 그 기능을 유추할 수 있도록 간결하면서 명확한 이름을 만들어야 합니다. 도움말 파일의 이름은 도움말을 제공하는 함수 혹은 메소드, 데이터 이름으로 정합니다.\n파일 이름은 절대로 non-ASCII 문자를 포함하면 안됩니다.\nR 패키지 골격 만들기\nRStudio의 기능을 이용하면 R 패키지의 골격을 쉽게 만들 수 있습니다.\n패키지의 이름을 koscrap이라고 미리 정합니다. “Korean Scraping”을 연상하여 이름을 정했습니다.\nFile > New Project… 메뉴를 선택하면, 다음과 같은 다이얼로그 창이 뜹니다.\n\n\n\nFigure 1: New Project Wizard 화면\n\n\n\n새로운 디렉토리에 패키지를 만들 것이므로 첫번째, New Directory를 선택합니다.\n\n\n\nFigure 2: R Package 선택 화면\n\n\n\nR 패키지 프로젝트를 만들 것이므로 두번째, R Package를 선택합니다.\n\n\n\nFigure 3: R Package 정의 화면\n\n\n\n패키지 이름에 “koscrap”을 기입하고, 패키지를 설치할 디렉토리도 선정합니다. 그리고 “Open in new session”의 체크박스를 선택합니다. 이 체크 박스는 패키지가 만들어지면 RStudio의 새로운 세션에서 해당 패키지 프로젝트를 열어 줍니다.\n“Create Project” 버튼을 누르면 RStudio의 새로운 세션이 다음처럼 열립니다.\n\n\n\nFigure 4: koscrap 패키지 프로젝트 세션 화면\n\n\n\nR 패키지 골격 살펴보기\n만들어진 R 패키지의 골격은 다음과 같습니다\n\n\n\nFigure 5: koscrap 패키지 디렉토리 구조\n\n\n\nhello.R이라는 R 소스 파일과 hello.Rd라는 도움말 파일이 만들어져 있습니다. 이들 파일의 내용을 살펴보겠습니다.\n\nDESCRIPTION\nPackage: koscrap\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nNAMESPACE\n\n\nexportPattern(\"^[[:alpha:]]+\")\n\n\n\nhello.R\n\n\n# Hello, world!\n#\n# This is an example function named 'hello' \n# which prints 'Hello, world!'.\n#\n# You can learn more about package authoring with RStudio at:\n#\n#   http://r-pkgs.had.co.nz/\n#\n# Some useful keyboard shortcuts for package authoring:\n#\n#   Install Package:           'Cmd + Shift + B'\n#   Check Package:             'Cmd + Shift + E'\n#   Test Package:              'Cmd + Shift + T'\n\nhello <- function() {\n  print(\"Hello, world!\")\n}\n\n\n\nhello.Rd\n\n\\name{hello}\n\\alias{hello}\n\\title{Hello, World!}\n\\usage{\nhello()\n}\n\\description{\nPrints 'Hello, world!'.\n}\n\\examples{\nhello()\n}\n\n\nR 패키지 개발하기\nDESCRIPTION 파일 수정하기\n\nPackage: koscrap\nType: Package \nTitle: Scrap from Public Data Portal & Naver \nVersion: 0.1.1.9000\nDate: 2022-01-31\nAuthors@R: c(\n  person(\"Choonghyun\", \"Ryu\",, \"choonghyun.ryu@gmail.com\", role = c(\"aut\", \"cre\"))\n  )\nDescription: Collect data using Open API from public data portal and scrap NAVER news article information.\nImports: \n    dplyr,\n    httr,\n    XML,\n    stringr,\n    purrr,\n    glue\nAuthor: Choonghyun Ryu [aut, cre]\nMaintainer: Choonghyun Ryu <choonghyun.ryu@gmail.com>\nLicense: GPL-2 | file LICENSE\nEncoding: UTF-8\nLazyData: true\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.1.1\n\n대표적인 태그의 의미는 다음과 같습니다.\nPackage\n패키지 이름 정의\n\nTitle, Description\n패키지 타이틀과 소개 정의\n\nVersion\n패키지 버전 정의\n0.1.1.9000\n0.1.1: 버전\n9000: 개발버전\n\n\nImports\n패키지의 종속성 정의\n패키지의 기능을 구현하기 위해서 반드시 필요한 패키지로 해당 패키지 설치시 자동으로 설치됩니다.\n\nAuthor, Maintainer\n패키지의 저자 및 유지보수 관리자\n\nLazyData\n데이터를 사용하기 전까지 메모리에 로드되지 않을지의 여부\ntrue일 경우에 사용전에는 메모리에 로드되지 않음\n\n소스파일 만들기\n다음처럼 두개의 소스 파일을 R 디렉토리에 복사해 넣습니다.\n\nsearch_naver.R\n\n\n#' 네이버 뉴스 검색\n#'\n#' @description 네이버 뉴스 검색 결과를 출력해주는 REST API를 호출하여, 뉴스 정보를 검색합니다.\n#'\n#' @details 네이버에서 발급받은 Client ID, Client Secret는 개인이 발급받은 키를 사용하며,\n#' 유출되어서는 안됩니다.\n#'\n#' @param query character. 검색을 원하는 문자열\n#' @param chunk_no integer. 검색 시작 위치로 최대 1000까지 가능\n#' @param chunk integer. 검색 결과 출력 건수 지정 (1~100)\n#' @param do_done logical. 한번의 호출로 모든 조회 결과를 가져오지 못할 경우,\n#' 추가로 호출해서 모든 결과를 가져올지의 여부\n#' @param sort character. 정렬 옵션: sim (유사도순), date (날짜순)\n#' @param max_record integer. 최대 조회할 건수. 실제로 검색한 건수는 max_record와 정확히 일치하지 않을 수 있습니다.\n#' chunk의 개수로 데이터를 수집하기 때문에 일반적인 경우에는 max_record보다 같거나  큰 chunk의 배수만큼 데이터를 가져옵니다.\n#' do_done가 FALSE일 경우에는 적용되지 않습니다.\n#' @param client_id character. 애플리케이션 등록 시 발급받은 Client ID\n#' @param client_secret character. 애플리케이션 등록 시 발급받은 Client Secret\n#'\n#' @return data.frame\n#' 변수 목록은 다음과 같음.:\n#' \\itemize{\n#' \\item title : character. 기사의 타이틀\n#' \\item originallink : character. 검색 결과 문서의 제공 언론사 하이퍼텍스트 link\n#' \\item link : character. 검색 결과 문서의 제공 네이버 하이퍼텍스트 link\n#' \\item description : character. 검색 결과 문서의 내용을 요약한 패시지 정보.\n#' 문서 전체의 내용은 link를 따라가면 읽을 수 있음. 패시지에서 검색어와 일치하는 부분은 태그로 감싸져 있음\n#' \\item publish_date : POSIXct. 검색 결과 문서가 네이버에 제공된 시간\n#' \\item title_text : character. 타이틀에서 HTML 태크를 제거한 텍스트\n#' \\item description_text : character. 요약한 패시지 정보에서 HTML 태크를 제거한 텍스트\n#' }\n#'\n#' @examples\n#' \\donttest{\n#' # Your authorized API keys\n#' client_id <- \"XXXXXXXXXXXXXXXXXXXXXXX\"\n#' client_secret <- \"XXXXXXXXX\"\n#'\n#' search_list <- search_naver(\n#'   \"불평등\", client_id = client_id, client_secret = client_secret\n#' )\n#'\n#' search_list <- search_naver(\n#'   \"불평등\", client_id = client_id, client_secret = client_secret,\n#'   do_done = TRUE, max_record = 350\n#' )\n#'\n#' }\n#'\n#' @import dplyr\n#' @importFrom XML xmlParse getNodeSet xmlValue xmlToDataFrame\n#' @importFrom httr GET add_headers\n#' @importFrom purrr map_df\n#' @importFrom glue glue\n#' @export\n#'\nsearch_naver <- function(query = NULL, chunk = 100, chunk_no = 1,\n                         sort = c(\"date\", \"sim\"), do_done = FALSE,\n                         max_record = 1000L, client_id = NULL,\n                         client_secret = NULL, verbose = TRUE) {\n  if (is.null(query)) {\n    stop(\"검색 키워드인 query를 입력하지 않았습니다.\")\n  }\n\n  if (chunk < 1 & chunk > 100) {\n    stop(\"chunk 요청 변수값이 허용 범위(1~100)인지 확인해 보세요.\")\n  }\n\n  if (chunk_no < 1 & chunk_no > 100) {\n    stop(\"chunk_no 요청 변수값이 허용 범위(1~1000)인지 확인해 보세요.\")\n  }\n\n  sort <- match.arg(sort)\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      rename(\"publish_date\" = pubDate) %>%\n      mutate(publish_date = as.POSIXct(publish_date,\n                                       format = \"%a, %d %b %Y %H:%M:%S %z\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title, \"&\\\\w+;|<[[:punct:]]*b>\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title_text, \"[[:punct:]]*\")) %>%\n      mutate(description_text = stringr::str_remove_all(\n        description,\n        \"&\\\\w+;|<[[:punct:]]*b>|[“”]\"))\n  }\n\n  searchUrl <- \"https://openapi.naver.com/v1/search/news.xml\"\n\n  query <- query %>%\n    enc2utf8() %>%\n    URLencode()\n\n  url <- glue::glue(\"{searchUrl}?query={query}&display={chunk}&start={chunk_no}&sort={sort}\")\n\n  doc <- url %>%\n    httr::GET(\n      httr::add_headers(\n        \"X-Naver-Client-Id\"     = client_id,\n        \"X-Naver-Client-Secret\" = client_secret\n      )\n    ) %>%\n    toString() %>%\n    XML::xmlParse()\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//total\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n  if (verbose) {\n    glue::glue(\"* 검색된 총 기사 건수는 {total_count}건입니다.\\n\\n\") %>%\n      cat()\n\n    glue::glue(\"  - ({chunk}/{min(total_count, max_record)})건 호출을 진행합니다.\\n\\n\") %>%\n      cat()\n  }\n\n  search_list <- doc %>%\n    get_list()\n\n  records <- NROW(search_list)\n\n  if (!do_done | records >= total_count | records >= max_record) {\n    return(search_list)\n  } else {\n    total_count <- min(total_count, max_record)\n\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    idx <- (seq(cnt) + 1)\n\n    add_list <- idx[idx <= 1000] %>%\n      purrr::map_df({\n        function(x) {\n          if (verbose) {\n            glue::glue(\"  - ({chunk * x}/{total_count})건 호출을 진행합니다.\\n\\n\") %>%\n              cat()\n          }\n\n          glue::glue(\n            \"{searchUrl}?query={query}&display={chunk}&start={x}&sort={sort}\"\n          ) %>%\n            httr::GET(\n              httr::add_headers(\n                \"X-Naver-Client-Id\"     = client_id,\n                \"X-Naver-Client-Secret\" = client_secret\n              )\n            ) %>%\n            toString() %>%\n            XML::xmlParse() %>%\n            get_list()\n        }\n      })\n\n    search_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n}\n\n\n\ntrade_apt.R\n\n\n#' 아파트 실거래 데이터 가져오기\n#'\n#' @description 공공데이터포털에서 REST open API로 아파트 실거래 데이터를 수집합니다.\n#'\n#' @details 공공데이터포털에서 발급받은 API 인증키는 개인이 발급받은 키를 사용하며,\n#' 유출되어서는 안됩니다.\n#'\n#' @param auth_key character. 공공데이터포털에서 발급받은 API 인증키\n#' @param LAWD_CD character. 지역코드. 각 지역별 코드 행정표준코드관리시스템\n#' (www.code.go.kr)의 법정동코드 10자리 중 앞 5자리\n#' @param DEAL_YMD character. 실거래 자료의 계약년월(6자리)\n#' @param chunk_no integer. 페이지번호\n#' @param chunk integer. 한 페이지 결과 수\n#' @param do_done logical. 한번의 호출로 모든 조회 결과를 가져오지 못할 경우,\n#' 추가로 호출해서 모든 결과를 가져올지의 여부\n#'\n#' @return data.frame\n#' 변수 목록은 다음과 같음.:\n#' \\itemize{\n#' \\item LAWD_CD : character. 지역코드\n#' \\item DEAL_DATE : character. 거래일자\n#' \\item SERIAL : character. 일련번호\n#' \\item BUILD_NM : character. 아파트 이름\n#' \\item FLOOR : integer. 층\n#' \\item BUILD_YEAR : integer. 건축년도\n#' \\item AREA : numeric. 전용면적\n#' \\item AMOUNT : integer. 거래금액\n#' \\item ROAD_CD : character. 도로명코드\n#' \\item ROAD_NM : character. 도로명\n#' \\item BUILD_MAJOR : character. 도로명건물본번호코드\n#' \\item BUILD_MINOR : character. 도로명건물부번호코드\n#' \\item ROAD_SEQ : character. 도로명일련번호코드\n#' \\item BASEMENT_FLAG : character. 도로명지상지하코드\n#' \\item LAND_NO : character. 지번\n#' \\item DONG_NM : character. 법정동\n#' \\item DONG_MAJOR : character. 법정동본번코드\n#' \\item DONG_MINOR : character. 법정동부번코드\n#' \\item EUBMYNDONG_CD : character. 법정동읍면동코드\n#' \\item DONG_LAND_NO : character. 법정동지번코드\n#' \\item DEALER_ADDR : character. 중개사소재지\n#' \\item CANCEL_DEAL : character. 해제여부\n#' \\item CANCEL_DATE : character. 해제사유발생일\n#' }\n#'\n#' @examples\n#' \\donttest{\n#' # Your authorized API keys\n#' auth_key <- \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n#'\n#' result <- trade_apt(auth_key, LAWD_CD = \"11680\", DEAL_YMD = \"202104\")\n#' result <- trade_apt(auth_key, LAWD_CD = \"11680\", DEAL_YMD = \"202104\", do_done = TRUE)\n#'\n#' }\n#'\n#' @import dplyr\n#' @importFrom XML xmlParse getNodeSet xmlValue xmlToDataFrame\n#' @importFrom stringr str_pad\n#' @importFrom purrr map_df\n#' @importFrom glue glue\n#' @export\ntrade_apt <- function(auth_key, LAWD_CD = \"11110\", DEAL_YMD = \"202112\",\n                      chunk_no = 1, chunk = 400, do_done = FALSE) {\n  library(dplyr)\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      mutate(거래금액 = stringr::str_remove(거래금액, \",\") %>%\n                   as.integer()) %>%\n      mutate(DEAL_DATE = glue::glue(\"{년}-{str_pad(월, width = 2, pad = '0')}-{\n                                  str_pad(일, width = 2, pad = '0')}\")) %>%\n      mutate(층 = as.integer(층)) %>%\n      mutate(건축년도 = as.integer(건축년도)) %>%\n      select(-년, -월, -일) %>%\n      select(\"LAWD_CD\"       = 지역코드,\n             DEAL_DATE,\n             \"SERIAL\"        = 일련번호,\n             \"DEAL_TYPE\"     = 거래유형,\n             \"BUILD_NM\"      = 아파트,\n             \"FLOOR\"         = 층,\n             \"BUILD_YEAR\"    = 건축년도,\n             \"AREA\"          = 전용면적,\n             \"AMOUNT\"        = 거래금액,\n             \"ROAD_CD\"       = 도로명코드,\n             \"ROAD_NM\"       = 도로명,\n             \"BUILD_MAJOR\"   = 도로명건물본번호코드,\n             \"BUILD_MINOR\"   = 도로명건물부번호코드,\n             \"ROAD_SEQ\"      = 도로명일련번호코드,\n             \"BASEMENT_FLAG\" = 도로명지상지하코드,\n             \"LAND_NO\"       = 지번,\n             \"DONG_NM\"       = 법정동,\n             \"DONG_MAJOR\"    = 법정동본번코드,\n             \"DONG_MINOR\"    = 법정동부번코드,\n             \"EUBMYNDONG_CD\" = 법정동읍면동코드,\n             \"DONG_LAND_NO\"  = 법정동지번코드,\n             \"DEALER_ADDR\"   = 중개사소재지,\n             \"CANCEL_DEAL\"   = 해제여부,\n             \"CANCEL_DATE\"   = 해제사유발생일)\n  }\n\n  api <- \"http://openapi.molit.go.kr/OpenAPI_ToolInstallPackage/service/rest/RTMSOBJSvc/getRTMSDataSvcAptTradeDev\"\n  url <- glue::glue(\n    \"{api}?ServiceKey={auth_key}&pageNo={chunk_no}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n  )\n\n  doc <- XML::xmlParse(url)\n\n  resultCode <- doc %>%\n    XML::getNodeSet(\"//resultCode\") %>%\n    XML::xmlValue()\n\n  if (resultCode != \"00\") {\n    result_msg <- doc %>%\n      XML::getNodeSet(\"//resultMsg\") %>%\n      XML::xmlValue()\n\n    stop(result_msg)\n  }\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//totalCount\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n  deal_list <- doc %>%\n    get_list()\n\n  records <- NROW(deal_list)\n\n  if (!do_done | records >= total_count) {\n    return(deal_list)\n  } else {\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    add_list <- (seq(cnt) + 1) %>%\n      purrr::map_df({\n        function(x) {\n          url <- glue::glue(\n            \"{api}?ServiceKey={auth_key}&pageNo={x}&numOfRows={chunk}&LAWD_CD={LAWD_CD}&DEAL_YMD={DEAL_YMD}\"\n          )\n\n          XML::xmlParse(url) %>%\n            get_list()\n        }\n      })\n\n    deal_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n}\n\n\n\n\n패키지 관련 파일의 자동 생성\nroxygen2\nroxygen2 패키지는 패키지를 개발할 때 help page를 기술하는 파일인 Rd 파일과 NAMESPACE 파일을 자동으로 작성해줍니다.\n일반적으로 Rd 파일은 패키지 홈 디렉토리의 man 디렉토리에 .Rd, .rd 포맷의 이름으로 만듧니다. 그런데 roxygen2 패키지는 패키지를 정의하는 R 소스 파일에 roxygen 형식으로 스크립트를 작성하면, 자동으로 Rd 파일을 생성해줍니다.\nNAMESPACE 파일에는 패키지에서 참조하는 다른 패키지나 패키지의 함수를 지정하는 import 정보 및 패키지의 함수에 접근할 수 있는 export 정보를 기술합니다.\n다음은 roxygen 형식으로 스크립트를 작성한 R 소스 파일의 예제입다.\n\n\n#' 두 월도 사이의 개월수 구하기\n#' @description 두개의 년월 사이에 몇 개의 개월이 포함되는 지를 구함\n#' @param start_year integer. 시작하는 년도를 나타내는 수치값\n#' @param start_month integer. 시작하는 월을 나타내는 수치값\n#' @param end_year integer. 종료하는 년도를 나타내는 수치값\n#' @param end_month integer. 종료하는 월을 나타내는 수치값\n#' @return 개월수를 나타내는 수치 벡터\n#' @author 유충현\n#' Maintainer: 유충현 <choonghyun.ryu@gmail.com>\n#' @seealso \\code{\\link{get_next_month}}, \\code{\\link{is_indate}}\n#' @examples\n#' get_month_length(2015, 3, 2017, 3)\n#' @export\nget_month_length <- function(start_year, start_month, end_year, end_month) {\n  ifelse(start_month > end_month, 12 + end_month - start_month +\n    (end_year - start_year - 1) * 12 + 1, end_month - start_month +\n    (end_year - start_year) * 12 + 1)\n}\n\n\n\nroxygen 스크립트의 시작은 #'로 시작합니다. 즉, R 소스 파일에서 #'로 시작하는 라인은 roxygen2 패키지가 해석하는 라인입니다.\nroxygen2 태그\nroxygen2의 대표적인 태그는 다음과 같습니다.:\n@title : Rd 파일의 \\title 태그로 기술될 태그\n함수의 타이틀을 기술\n@title을 기술하지 않으면, 첫 줄의 내용이 \\title 태그로 기술됨\n\n@description : Rd 파일의 태그로 기술될 태그\n함수의 상세 설명을 기술\n\n@param : Rd 파일의 태그 내의\n태그로 기술될 태그\n함수의 인수 이름과 그 내용을 기술\n\n@return : Rd 파일의 태그로 기술될 태그\n함수가 반환하는 값에 대한 설명을 기술\n\n@author : Rd 파일의 \\author 태그로 기술될 태그\n함수 개발자 정보를 기술\n\n@seealso : Rd 파일의 태그로 기술될 태그\n함께 알아두면 유용한 관련 함수를 기술\n\n@examples : Rd 파일의 태그로 기술될 태그\n함수의 사용 예제를 기술\n\n@export : NAMESPACE 파일의 export() 함수로 기술될 태그\nNAMESPACE 파일에서의 export 정보를 기술할지의 여부를 지정\n해당 태그를 기술할 경우만 export 정보를 기술한다.\n\nroxygen2 태그 기반 자동 생성\nroxygen2 패키지의 roxygenise() 함수는 R 소스 파일의 roxygen2 태그를 해석하여 도움말 파일인 Rd 파일과 NAMESPACE 파일을 생성합니다. 또한 DESCRIPTION 파일도 업데이트합니다.\n다음 스크립트를 실행하면 R/misc.R 파일을 읽어서 Rd 파일과 NAMESPACE 파일을 생성하고, DESCRIPTION 파일을 업데이트 합니다.\n\n\nroxygen2::roxygenise()\n\n\n\nRd 파일의 생성\nroxygenise()의 실행으로, 앞에서 만든 “search_naver.R”과 “trade_apt.R” 파일의 roxygen2 태그는 도움말 파일을 만들어졌습니다. 이 두 개의 도움말 중에서 “search_naver.Rd”는 다음과 같습니다.\n\n% Generated by roxygen2: do not edit by hand\n% Please edit documentation in R/search_naver.R\n\\name{search_naver}\n\\alias{search_naver}\n\\title{네이버 뉴스 검색}\n\\usage{\nsearch_naver(\n  query = NULL,\n  chunk = 100,\n  chunk_no = 1,\n  sort = c(\"date\", \"sim\"),\n  do_done = FALSE,\n  max_record = 1000L,\n  client_id = NULL,\n  client_secret = NULL,\n  verbose = TRUE\n)\n}\n\\arguments{\n\\item{query}{character. 검색을 원하는 문자열}\n\n\\item{chunk}{integer. 검색 결과 출력 건수 지정 (1~100)}\n\n\\item{chunk_no}{integer. 검색 시작 위치로 최대 1000까지 가능}\n\n\\item{sort}{character. 정렬 옵션: sim (유사도순), date (날짜순)}\n\n\\item{do_done}{logical. 한번의 호출로 모든 조회 결과를 가져오지 못할 경우,\n추가로 호출해서 모든 결과를 가져올지의 여부}\n\n\\item{max_record}{integer. 최대 조회할 건수. 실제로 검색한 건수는 max_record와 정확히 일치하지 않을 수 있습니다.\nchunk의 개수로 데이터를 수집하기 때문에 일반적인 경우에는 max_record보다 같거나  큰 chunk의 배수만큼 데이터를 가져옵니다.\ndo_done가 FALSE일 경우에는 적용되지 않습니다.}\n\n\\item{client_id}{character. 애플리케이션 등록 시 발급받은 Client ID}\n\n\\item{client_secret}{character. 애플리케이션 등록 시 발급받은 Client Secret}\n}\n\\value{\ndata.frame\n변수 목록은 다음과 같음.:\n\\itemize{\n\\item title : character. 기사의 타이틀\n\\item originallink : character. 검색 결과 문서의 제공 언론사 하이퍼텍스트 link\n\\item link : character. 검색 결과 문서의 제공 네이버 하이퍼텍스트 link\n\\item description : character. 검색 결과 문서의 내용을 요약한 패시지 정보.\n문서 전체의 내용은 link를 따라가면 읽을 수 있음. 패시지에서 검색어와 일치하는 부분은 태그로 감싸져 있음\n\\item publish_date : POSIXct. 검색 결과 문서가 네이버에 제공된 시간\n\\item title_text : character. 타이틀에서 HTML 태크를 제거한 텍스트\n\\item description_text : character. 요약한 패시지 정보에서 HTML 태크를 제거한 텍스트\n}\n}\n\\description{\n네이버 뉴스 검색 결과를 출력해주는 REST API를 호출하여, 뉴스 정보를 검색합니다.\n}\n\\details{\n네이버에서 발급받은 Client ID, Client Secret는 개인이 발급받은 키를 사용하며,\n유출되어서는 안됩니다.\n}\n\\examples{\n\\donttest{\n# Your authorized API keys\nclient_id <- \"XXXXXXXXXXXXXXXXXXXXXXX\"\nclient_secret <- \"XXXXXXXXX\"\n\nsearch_list <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret\n)\n\nsearch_list <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret,\n  do_done = TRUE, max_record = 350\n)\n\n}\n\n}\n\n그리고 패키지가 Build되면 이 도움말은 다음과 같은 도움말을 제공하게 됩니다.\n\n\n\nFigure 6: search_naver 함수의 도움말 화면\n\n\n\nNAMESPACE 파일의 생성\nNAMESPACE 파일도 변경되었습니다.\n@export 태그를 사용한 두 함수는 export()로, 그리고 참조하는 다른 패키지와 함수들은 import(), importFrom()로 기술되었습니다.\n\n\n# Generated by roxygen2: do not edit by hand\n\nexport(search_naver)\nexport(trade_apt)\nimport(dplyr)\nimportFrom(XML,getNodeSet)\nimportFrom(XML,xmlParse)\nimportFrom(XML,xmlToDataFrame)\nimportFrom(XML,xmlValue)\nimportFrom(glue,glue)\nimportFrom(httr,GET)\nimportFrom(httr,add_headers)\nimportFrom(purrr,map_df)\nimportFrom(stringr,str_pad)\n\n\n\nR 데이터 생성\n아파트 실거래 상세 조회를 위해서 법정동 코드가 필요합니다. 그래서 이 코드 정보를 패키지에 포함하려 합니다.\nR 데이터 파일 생성\nR 패키지에서 외부 파일을 넣는 디렉토리인 “inst”에 “meta”라는 디렉토리를 만든 후 법정동 코드 파일인 “법정동코드 전체자료.txt”을 복사해 넣은 뒤에 다음의 코드를 실행합니다.\n\n\nlibrary(dplyr)\nfname <- here::here(\"inst\", \"meta\", \"법정동코드 전체자료.txt\")\nlegal_divisions <- fname %>%\n  read.table(sep = \"\\t\", header = TRUE, fileEncoding = \"cp949\",\n             col.names = c(\"DIVISION_ID\", \"DIVISION_NM\", \"MAINTAIN\")) %>%\n  mutate(DIVISION_ID = format(DIVISION_ID, scientific = FALSE, trim = TRUE)) %>%\n  mutate(MAINTAIN = case_when(\n    MAINTAIN == \"존재\" ~ \"Y\",\n    MAINTAIN == \"폐지\" ~ \"N\")\n  ) %>%\n  mutate(MEGA_CD = substr(DIVISION_ID, 1, 2),\n         MEGA_NM = stringr::str_extract(DIVISION_NM, \"^[\\\\w]+\")) %>%\n  mutate(CTY_CD = substr(DIVISION_ID, 1, 5),\n         CTY_NM = stringr::str_extract(DIVISION_NM, \" [\\\\w]+\") %>%\n           stringr::str_remove(\"\\\\s\")) %>%\n  mutate(ADMI_CD = substr(DIVISION_ID, 1, 8),\n         ADMI_NM = stringr::str_remove(DIVISION_NM, \"^[\\\\w]+ [\\\\w]+ \")) %>%\n  filter(!stringr::str_detect(DIVISION_ID, \"000000$\"))\n\nsave(legal_divisions, file = \"data/legal_divisions.rda\")\n\n\ndb_name <- here::here(\"inst\", \"meta\", \"GISDB.sqlite\")\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), db_name)\nDBI::dbWriteTable(con, \"TB_LEGAL_DIVISIONS\", legal_divisions, overwrite = TRUE)\nDBI::dbDisconnect(con)\n\n\n\n이 코드가 실행되면, “./inst/meta” 경로에 “법정동코드 전체자료.txt”, “GISDB.sqlite”가 위치하고 “./data” 경로에 “legal_divisions.rda” 파일이 위치하게 됩니다.\nR 데이터 도움말 파일 생성\nlegal_divisons.R 파일에 도움말을 위한 roxygen2 태그를 기술하고, 앞에서 데이터를 만든 코드를 주석으로 보관합니다. 데이터의 도움말을 생성하는 roxygen2 태그는 함수의 도움말을 생성하는 것과 다소 차이가 있습니다.\n\n\n#' 행정구역 코드 정보\n#'\n#' @description\n#' 행정표준관리시스템의 법정동코드 전체자료로부터 추출한 광역시도,시군구, 읍면동 레벨의 코드 정보.\n#'\n#' @details\n#' 공공데이터포털에서 Open API로 행정구역 관련 데이터를 수집할 때, 입력 파라미터로 조직 코드를 사용할 경우가 많습니다.\n#' 이때 이 정보를 이용해서 원하는 지역의 정보를 수집할 수 있습니다.\n#'\n#' @format 45953 관측치와 9 변수를 갖는 data.frame. 다음과 같은 변수를 포함합니다.:\n#' \\describe{\n#'   \\item{DIVISION_ID}{charcter. 법정동 코드.}\n#'   \\item{DIVISION_NM}{charcter. 법정동 이름.}\n#'   \\item{MAINTAIN}{logical. 유지여부.}\n#'   \\item{MEGA_CD}{charcter. 광역시도 코드.}\n#'   \\item{MEGA_NM}{charcter. 광역시도 이름.}\n#'   \\item{CTY_CD}{charcter. 시군구 코드.}\n#'   \\item{CTY_NM}{charcter. 시군구 이름.}\n#'   \\item{ADMI_CD}{charcter. 읍면동 코드.}\n#'   \\item{ADMI_NM}{charcter. 읍면동 이름.}\n#' }\n#' @docType data\n#' @keywords datasets\n#' @name legal_divisions\n#' @usage data(legal_divisions)\n#' @source {\n#' \"행정표준관리시스템\" <https://www.code.go.kr/stdcodesrch/codeAllDownloadL.do>\n#' }\nNULL\n\n# library(dplyr)\n# fname <- here::here(\"inst\", \"meta\", \"법정동코드 전체자료.txt\")\n# legal_divisions <- fname %>%\n#   read.table(sep = \"\\t\", header = TRUE, fileEncoding = \"cp949\",\n#              col.names = c(\"DIVISION_ID\", \"DIVISION_NM\", \"MAINTAIN\")) %>%\n#   mutate(DIVISION_ID = format(DIVISION_ID, scientific = FALSE, trim = TRUE)) %>%\n#   mutate(MAINTAIN = case_when(\n#     MAINTAIN == \"존재\" ~ \"Y\",\n#     MAINTAIN == \"폐지\" ~ \"N\")\n#   ) %>%\n#   mutate(MEGA_CD = substr(DIVISION_ID, 1, 2),\n#          MEGA_NM = stringr::str_extract(DIVISION_NM, \"^[\\\\w]+\")) %>%\n#   mutate(CTY_CD = substr(DIVISION_ID, 1, 5),\n#          CTY_NM = stringr::str_extract(DIVISION_NM, \" [\\\\w]+\") %>%\n#            stringr::str_remove(\"\\\\s\")) %>%\n#   mutate(ADMI_CD = substr(DIVISION_ID, 1, 8),\n#          ADMI_NM = stringr::str_remove(DIVISION_NM, \"^[\\\\w]+ [\\\\w]+ \")) %>%\n#   filter(!stringr::str_detect(DIVISION_ID, \"000000$\"))\n#\n# save(legal_divisions, file = \"data/legal_divisions.rda\")\n#\n#\n# db_name <- here::here(\"inst\", \"meta\", \"GISDB.sqlite\")\n#\n# con <- DBI::dbConnect(RSQLite::SQLite(), db_name)\n# DBI::dbWriteTable(con, \"TB_LEGAL_DIVISIONS\", legal_divisions, overwrite = TRUE)\n# DBI::dbDisconnect(con)\n\n\n\nvignette 작성하기\nvignette 골격 생성하기\nusethis::use_vignette(“intro”, title = “introduce koscrap”) 명령어를 통해서 vignette 골격을 생성합니다. 이 명령어는 vignette의 타이틀이 “introduce koscrap”인 “intro.Rmd”라는 마크다운 문서 템플리트를 생성합니다. 또한 출력되는 메시지처럼 여러 작업을 수행합니다.\n\n> usethis::use_vignette(\"intro\", title = \"introduce koscrap\")\n✓ Setting active project to '/Users/choonghyunryu/Documents/01_Personal/00_bitr/01_packages/koscrap'\n✓ Adding 'knitr' to Suggests field in DESCRIPTION\n✓ Setting VignetteBuilder field in DESCRIPTION to 'knitr'\n✓ Adding 'inst/doc' to '.gitignore'\n✓ Creating 'vignettes/'\n✓ Adding '*.html', '*.R' to 'vignettes/.gitignore'\n✓ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✓ Writing 'vignettes/intro.Rmd'\n• Modify 'vignettes/intro.Rmd'\n> \n\nvignette 템플리트인 “intro.Rmd”은 다음과 같습니다.\n---\ntitle: \"introduce koscrap\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{introduce koscrap}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n```{r, include = FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n```\n\n```{r setup}\nlibrary(koscrap)\n```\n\nvignette 작성하기\n템플리트를 토대로 해서 다음과 같은 vignette을 작성하였습니다. vignette에 명령어와 결과를 포함하여 작성한 이유는, API를 호출하기 위한 클라이언트 아이디, 보안키 등을 노출하지 않기 위함입니다. 만약 실행 코드만으로 vignette을 작성하려면, 클라이언트 아이디, 보안키 등의 노출되기 때문입니다.\n---\ntitle: \"introduce koscrap\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{introduce koscrap}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n## koscrap에 대하여\nkoscrap(Korean Scraping)은 공공데이터포털의 아파트실거래 상세 내역과 NAVER의 뉴스검색 데이터를 수집하는 패키지입니다. REST 오픈 API를 이용해서 정해진 데이터를 수집할 수 있습니다.\n\n## koscrap 기능\n현재 구현된 koscrap의 기능을 다음과 같습니다.\n\n* 공공데이터포털의 아파트실거래\n  - trade_apt()\n* NAVER의 뉴스검색 \n  - search_naver()\n\n## 공공데이터포털의 아파트실거래 예제\n서울특별시 노원구의 2021년도 12월의 아파트 거래 내역을 수집합니다.\n\n먼저 공공데이터포털에서 발급받은 서비스키를 기술합니다. 본 예제는 서비스키는 개인의 정보이므로 여기서는 임의의 문자로 형식만 표기합니다.\n\n```{r, eval=FALSE}\nlibrary(\"koscrap\")\nlibrary(\"dplyr\")\n\nauth_key <- \"xxxxxxxxxxxxxxxxxxx\"\n```\n\n패키지에서 제공하는 법정동 코드 데이터인 `legal_divisions`로부터 노원구의 시군구 코드를 가져옵니다. 그리고 `trade_apt()`로 아파트거래정보를 수집합니다.\n\n```{r, eval=FALSE}\nLAWD_CD <- legal_divisions %>% \n  filter(CTY_NM %in% \"노원구\") %>% \n  select(CTY_CD) %>% \n  filter(row_number() == 1) %>% \n  pull()\n\nnowon <- trade_apt(auth_key, \n          LAWD_CD = LAWD_CD, \n          DEAL_YMD = \"202112\")\n\nglimpse(nowon)\n#> Rows: 59\n#> Columns: 24\n#> $ LAWD_CD       <chr> \"11350\", \"11350\", \"11350\", \"11350\", \"11350\", \"11350\", \"1…\n#> $ DEAL_DATE     <glue> \"2021-12-05\", \"2021-12-06\", \"2021-12-07\", \"2021-12-10\",…\n#> $ SERIAL        <chr> \"11350-149\", \"11350-133\", \"11350-150\", \"11350-151\", \"113…\n#> $ DEAL_TYPE     <chr> \"중개거래\", \"중개거래\", \"중개거래\", \"직거래\", \"중개거래\"…\n#> $ BUILD_NM      <chr> \"주공2\", \"한진한화그랑빌\", \"청백3\", \"청백4\", \"주공2\", \"…\n#> $ FLOOR         <int> 4, 24, 13, 14, 12, 2, 15, 9, 9, 12, 14, 19, 15, 8, 16, 1…\n#> $ BUILD_YEAR    <int> 1992, 2002, 1998, 1998, 1992, 2000, 1992, 1987, 1994, 19…\n#> $ AREA          <chr> \"58.65\", \"114.97\", \"39.84\", \"84.54\", \"44.52\", \"84.98\", \"…\n#> $ AMOUNT        <int> 67500, 125000, 42500, 75000, 53800, 84500, 48000, 73600,…\n#> $ ROAD_CD       <chr> \"4130377\", \"3109006\", \"4130332\", \"4130332\", \"4130377\", \"…\n#> $ ROAD_NM       <chr> \"초안산로1길\", \"마들로\", \"월계로45가길\", \"월계로45가길\",…\n#> $ BUILD_MAJOR   <chr> \"00018\", \"00031\", \"00089\", \"00094\", \"00018\", \"00049\", \"0…\n#> $ BUILD_MINOR   <chr> \"00000\", \"00000\", \"00000\", \"00000\", \"00000\", \"00000\", \"0…\n#> $ ROAD_SEQ      <chr> \"01\", \"01\", \"01\", \"01\", \"01\", \"01\", \"01\", \"01\", \"01\", \"0…\n#> $ BASEMENT_FLAG <chr> \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"…\n#> $ LAND_NO       <chr> \"556\", \"18\", \"780\", \"781\", \"556\", \"929\", \"556\", \"12\", \"7…\n#> $ DONG_NM       <chr> \" 월계동\", \" 월계동\", \" 월계동\", \" 월계동\", \" 월계동\", \"…\n#> $ DONG_MAJOR    <chr> \"0556\", \"0018\", \"0780\", \"0781\", \"0556\", \"0929\", \"0556\", …\n#> $ DONG_MINOR    <chr> \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", \"0000\", …\n#> $ EUBMYNDONG_CD <chr> \"10200\", \"10200\", \"10200\", \"10200\", \"10200\", \"10200\", \"1…\n#> $ DONG_LAND_NO  <chr> \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"…\n#> $ DEALER_ADDR   <chr> \"서울 강북구, 서울 성북구\", \"서울 노원구\", \"서울 노원구\"…\n#> $ CANCEL_DEAL   <chr> \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"…\n#> $ CANCEL_DATE   <chr> \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"…\n```\n\n노원구에서 12월에 가장 고가로 매매된 아파트의 가격은 13억3천5백만원입니다. 그리고 매매건수는 상계동>중계동>공릉동 순입니다.\n\n```{r, eval=FALSE}\nnowon %>% \n  summarise(max_price = max(AMOUNT))\n#>   max_price\n#> 1    133500\n\nnowon %>% \n  group_by(DONG_NM) %>% \n  tally() %>% \n  arrange(desc(n))\n#> # A tibble: 5 x 2\n#>   DONG_NM       n\n#>   <chr>     <int>\n#> 1 \" 상계동\"    27\n#> 2 \" 중계동\"    11\n#> 3 \" 공릉동\"    10\n#> 4 \" 월계동\"     8\n#> 5 \" 하계동\"     3\n```\n2006년 10월의 성동구의 매매 현황을 수집합니다. chunk의 값을 800으로 지정해서 765건을 수집했습니다. chunk의 기본값은 100으로 100건을 수집합니다.\n\n```{r, eval=FALSE}\nLAWD_CD <- legal_divisions %>% \n  filter(CTY_NM %in% \"성동구\") %>% \n  select(CTY_CD) %>% \n  filter(row_number() == 1) %>% \n  pull()\n\nsungdong <- trade_apt(auth_key, \n                      LAWD_CD = \"11200\", \n                      DEAL_YMD = \"200610\",\n                      chunk = 800)\n\nNROW(sungdong)\n#> [1] 765\n```\n  \n## 네이버 뉴스 검색 예제\n\"불평등\"이라는 키워드로 뉴스현황을 검색합니다.\n\n사용자의 클라이언트 아이디와 보안키를 입력합니다. 사전에 네이버로부터 발급받아야 합니다.\n\n```{r, eval=FALSE}\n# Your authorized API keys\nclient_id <- \"XXXXXXXXXXXXXXXXXXXXXXX\"\nclient_secret <- \"XXXXXXXXX\"\n```\n\n총 285,030건의 뉴스가 검색되었고 100건을 수집했습니다.\n\n```{r, eval=FALSE}\ninequality <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret\n)\n#> * 검색된 총 기사 건수는 285036건입니다.\n#> - (100/285036)건 호출을 진행합니다.\n```\n\n1000건을 수집해 보겠습니다.\n\n```{r, eval=FALSE}\ninequality_1000 <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret,\n  do_done = TRUE, max_record = 1000\n)\n#> * 검색된 총 기사 건수는 285036건입니다.\n#> - (100/1000)건 호출을 진행합니다.\n#> - (200/1000)건 호출을 진행합니다.\n#> - (300/1000)건 호출을 진행합니다.\n#> - (400/1000)건 호출을 진행합니다.\n#> - (500/1000)건 호출을 진행합니다.\n#> - (600/1000)건 호출을 진행합니다.\n#> - (700/1000)건 호출을 진행합니다.\n#> - (800/1000)건 호출을 진행합니다.\n#> - (900/1000)건 호출을 진행합니다.\n#> - (1000/1000)건 호출을 진행합니다.\n```\n\n```{r, eval=FALSE}\nhead(inequality_1000)\n#>                                                                               title\n#> 1                                          이재명 후보, 문화예술 분야 6대 공약 발표\n#> 2                        조영수 이사장 “다른 사람의 관점에서 나를 성찰하게 하는 책”\n#> 3                [D:이슈] 장르물에 녹여낸 한국 사회…넷플릭스 오리지널 장점이자 한계\n#> 4              &quot;기후위기 대응 64개국 중 59위…우물 안 K-대통령 돼선 안 돼&quot;\n#> 5                       [지자체의 SR] 의정부시, 스마트시티 조성 탄력…국비 20억 확보\n#> 6 이재명 &quot;미래산업 핵심은 재생에너지&quot; 윤석열 &quot;데이터·AI가 핵심&quot;\n#>                                                                     originallink\n#> 1 http://www.cine21.com/news/view/?mag_id=99572&utm_source=naver&utm_medium=news\n#> 2                                         http://ch.yes24.com/Article/View/46942\n#> 3                          https://www.dailian.co.kr/news/view/1079823/?sc=Naver\n#> 4                                       https://www.nocutnews.co.kr/news/5700762\n#> 5                       http://www.srtimes.kr/news/articleView.html?idxno=107666\n#> 6                        https://www.eroun.net/news/articleView.html?idxno=27524\n#>                                                                                      link\n#> 1 https://news.naver.com/main/read.naver?mode=LSD&mid=sec&sid1=106&oid=140&aid=0000046515\n#> 2                                                  http://ch.yes24.com/Article/View/46942\n#> 3 https://news.naver.com/main/read.naver?mode=LSD&mid=sec&sid1=103&oid=119&aid=0002572721\n#> 4 https://news.naver.com/main/read.naver?mode=LSD&mid=sec&sid1=102&oid=079&aid=0003604477\n#> 5                                http://www.srtimes.kr/news/articleView.html?idxno=107666\n#> 6                                 https://www.eroun.net/news/articleView.html?idxno=27524\n#>                                                                                                                                                                                                                                                                         description\n#> 1                                                               방식의 영화 제작 지원을 확대하고, 애니메이션 투자펀드를 만들겠다는 것이다. 이 후보는 대기업의 독과점, 계약 관계의 <b>불평등<\/b> 등을 시정해 문화예술 분야에 공정한 생태계를 조성할 수 있도록 노력하겠다고 강조했다.\n#> 2                                                               그리고 글로벌 각국이 갖는 <b>불평등<\/b>에 대한 의문을 해소해주는 책이죠. 『수레바퀴 밑에서』 헤르만 헤세 저 수레바퀴 밑에서 헤르만 헤세 저 | 강태정 역 일신서적출판사 주인공 한스의 방황과 고뇌가 고등학생 시절... \n#> 3                                                              나아가 극한 경쟁에 내몰린 현대인과 개인의 힘으로는 극복하기 힘든 <b>불평등<\/b> 문제 등 작품에 녹아있는 메시지도 ‘오징어 게임’을 한층 새로운 데스 게임 드라마로 보이게 했다. 그러나 국내 시청자들은 ‘오징어 게임’... \n#> 4                                                 그다음에 <b>불평등<\/b> 여러 가지 쭉 나오는데 이 기후위기는 10위 안에도 못 들어갔습니다. ◇이윤상&gt; 기후위기가... 물론 부동산, 일자리, <b>불평등<\/b> 모두 중요하지만 기후위기는 모든 인류를 다 끝내는 거 아닙니까 그래서 이런... \n#> 5                                                            사업 대상지 내 중랑천 약 4Km 구간에 다목적 AI 스마트 폴 및 스마트 게이트 등을 구축해 사물인터넷과 스마트 정보 체계를 연동하고 홍수 등 재난 위험 상황에 대한 즉각 대응체계 마련 및 정보 서비스 <b>불평등<\/b> 환경을... \n#> 6 尹 &quot;핵폐기물 처리기술 고도화될 것&quot; 李 &quot;원전 정략대상 아냐&quot; 심상정 &quot;<b>불평등<\/b> 해소·녹색전환&quot; 안철수... 沈 &quot;<b>불평등<\/b> 해소·녹색전환&quot; 安 &quot;과학기술 주권국가&quot; 강조 토론 중에는 각 후보의 일자리·성장 방안에 대한 철학도... \n#>          publish_date\n#> 1 2022-02-04 15:17:00\n#> 2 2022-02-04 14:56:00\n#> 3 2022-02-04 14:49:00\n#> 4 2022-02-04 14:44:00\n#> 5 2022-02-04 14:42:00\n#> 6 2022-02-04 14:14:00\n#>                                                       title_text\n#> 1                        이재명 후보 문화예술 분야 6대 공약 발표\n#> 2       조영수 이사장 다른 사람의 관점에서 나를 성찰하게 하는 책\n#> 3 D이슈 장르물에 녹여낸 한국 사회넷플릭스 오리지널 장점이자 한계\n#> 4         기후위기 대응 64개국 중 59위우물 안 K대통령 돼선 안 돼\n#> 5        지자체의 SR 의정부시 스마트시티 조성 탄력국비 20억 확보\n#> 6       이재명 미래산업 핵심은 재생에너지 윤석열 데이터AI가 핵심\n#>                                                                                                                                                                                                  description_text\n#> 1    방식의 영화 제작 지원을 확대하고, 애니메이션 투자펀드를 만들겠다는 것이다. 이 후보는 대기업의 독과점, 계약 관계의 불평등 등을 시정해 문화예술 분야에 공정한 생태계를 조성할 수 있도록 노력하겠다고 강조했다.\n#> 2    그리고 글로벌 각국이 갖는 불평등에 대한 의문을 해소해주는 책이죠. 『수레바퀴 밑에서』 헤르만 헤세 저 수레바퀴 밑에서 헤르만 헤세 저 | 강태정 역 일신서적출판사 주인공 한스의 방황과 고뇌가 고등학생 시절... \n#> 3   나아가 극한 경쟁에 내몰린 현대인과 개인의 힘으로는 극복하기 힘든 불평등 문제 등 작품에 녹아있는 메시지도 ‘오징어 게임’을 한층 새로운 데스 게임 드라마로 보이게 했다. 그러나 국내 시청자들은 ‘오징어 게임’... \n#> 4 그다음에 불평등 여러 가지 쭉 나오는데 이 기후위기는 10위 안에도 못 들어갔습니다. ◇이윤상 기후위기가... 물론 부동산, 일자리, 불평등 모두 중요하지만 기후위기는 모든 인류를 다 끝내는 거 아닙니까 그래서 이런... \n#> 5 사업 대상지 내 중랑천 약 4Km 구간에 다목적 AI 스마트 폴 및 스마트 게이트 등을 구축해 사물인터넷과 스마트 정보 체계를 연동하고 홍수 등 재난 위험 상황에 대한 즉각 대응체계 마련 및 정보 서비스 불평등 환경을... \n#> 6         尹 핵폐기물 처리기술 고도화될 것 李 원전 정략대상 아냐 심상정 불평등 해소·녹색전환 안철수... 沈 불평등 해소·녹색전환 安 과학기술 주권국가 강조 토론 중에는 각 후보의 일자리·성장 방안에 대한 철학도...\n```\nvignette 빌드하기\ndevtools::build_vignettes() 명령어를 통해서 vignette을 빌드합니다.\n\n> devtools::build_vignettes()\nBuilding koscrap vignettes\n--- re-building ‘intro.Rmd’ using rmarkdown\n--- finished re-building ‘intro.Rmd’\n\n✓ Creating 'doc/'\n✓ Adding '^doc$' to '.Rbuildignore'\n✓ Adding 'doc' to '.gitignore'\nMoving intro.html, intro.R to doc/\nCopying intro.Rmd to doc/\n✓ Creating 'Meta/'\n✓ Adding '^Meta$' to '.Rbuildignore'\n✓ Adding 'Meta' to '.gitignore'\nBuilding vignette index\n> \n\n“Meta” 디렉토리는 vignette에 대한 메타정보를 포함하고 있습니다.\n빌드 후 생성된 “doc” 리렉토리는 “inst” 디렉토리 하위 디렉토리로 이동시켜야 합니다.\n개발자의 koscrap 패키지 설치하기\n이제 R패키가 얼추 만들어졌습니다. 마지막으로 패키지를 빌드하는 일만 남았습니다.\nR 패키지 설치하기\n패키지를 설치하기 위해서 RStudio의 “build 탭 메뉴”의 “Install and Restart”를 사용합니다.\n\n\n\nFigure 7: R 패키지 설치\n\n\n\nR 패키지 설치하는 과정이 집행된 후, 정상적으로 패키지가 만들어지면 자동적으로 콘솔 화면에서 library() 함수로 패키지를 로딩합니다.\nkoscrap 패키지 사용하기\nkoscrap 패키지의 도움말을 선택하면, 다음과 같은 화면을 만나게 됩니다.\n\n\n\nFigure 8: koscrap 도움말 홈페이지\n\n\n\n다음 명령어를 입력하면 vignette 문서를 볼 수 있습니다.\n\n\nvignette(\"intro\", package = \"koscrap\")\n\n\n\n\n\n\nFigure 9: koscrap vignette 화면\n\n\n\n공공데이터포털의 아파트 실거래 상세조회를 수행해 봅니다.\n먼저 사용자의 서비스키를 입력합니다. 여기서는 서비스키의 보안 유지를 위해서 임의의 문자로 채워 넣었습니다.\n\n\nlibrary(\"koscrap\")\nauth_key <- \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\n\n\n2020년 6월 지역코드가 “11290”인 곳의 거래 정보를 가져옵니다. chunk가 1000이므로 한번 호출에 1000건 이내의 정보를 가져옵니다. 물론 해당 지역의 거래건수 내에서 가져오게 됩니다. do_done이 TRUE인 의미는 만약 해당 지역의 해당원 거래량이 chunk에서 지정한 건수보다 클 경우에, 함수 내부적으로 추가 호출하여 전 건을 가져오라는 의미입니다.\n\nresult <- trade_apt(auth_key, LAWD_CD = \"11290\", DEAL_YMD = \"202006\", chunk = 1000, do_done = TRUE)\n\n> head(result)\n  LAWD_CD  DEAL_DATE   SERIAL DEAL_TYPE BUILD_NM FLOOR BUILD_YEAR   AREA AMOUNT ROAD_CD      ROAD_NM\n1   11290 2020-06-01  11290-4               성북     3       1971  37.36  17000 4121350   성북로31길\n2   11290 2020-06-03  11290-4               성북     1       1971  37.36  14500 4121350   성북로31길\n3   11290 2020-06-11  11290-4               성북     2       1971  37.36  15000 4121350   성북로31길\n4   11290 2020-06-15 11290-11           성북좋은     5       2002 113.54  80000 4121353  성북로6가길\n5   11290 2020-06-18  11290-4               성북     1       1971  37.36  16000 4121350   성북로31길\n6   11290 2020-06-22  11290-8               주암     3       1972  48.73  23000 4121349 성북로31가길\n  BUILD_MAJOR BUILD_MINOR ROAD_SEQ BASEMENT_FLAG LAND_NO DONG_NM DONG_MAJOR DONG_MINOR EUBMYNDONG_CD\n1       00040       00012       01             0   348-3  성북동       0348       0003         10100\n2       00040       00012       01             0   348-3  성북동       0348       0003         10100\n3       00040       00012       01             0   348-3  성북동       0348       0003         10100\n4       00023       00000       01             0  179-96  성북동       0179       0096         10100\n5       00040       00012       01             0   348-3  성북동       0348       0003         10100\n6       00005       00000       01             0     286  성북동       0286       0000         10100\n  DONG_LAND_NO DEALER_ADDR CANCEL_DEAL CANCEL_DATE\n1            1                                    \n2            1                                    \n3            1                                    \n4            1                                    \n5            1                                    \n6            1                                     \n\n이상으로 koscrap 패키지의 간단한 사용을 통해서 패키지가 이상없이 만들어졌음을 파악했습니다.\n사용자의 koscrap 패키지 설치하기\nkoscrap 패키지는 github의 public repository에 올려 놓았습니다. github은 CRAN과 더불어 많은 R 패키지를 배포하는 채널이기도 합니다. CRAN은 까다로운 조건 때문에 R 패키지를 submit하기 쉽지 않습니다. 어떤 경우에는 제약을 해결하지 못하는 관계로 github에만 패키지를 등록하는 경우도 있습니다.\n여기서는 github에 올려 놓은 패키지를 설치하는 방법을 다룹니다.\ndevtools 패키지 설치\n먼저 devtools 패키지를 설치합니다.\n\n\ninstall.packages(\"devtools\")\n\n\n\nkoscrap 패키지 설치\ndevtools 패키지의 install_github() 함수로 koscrap 패키지를 설치합니다.\nkoscrap 패키지의 리파지토리 URL이 https://github.com/choonghyunryu/koscrap이므로 뒷 자리의 정보 사용자/리파지토리이름을 기술하려 설치합니다.\n\n\ndevtools::install_github(\"choonghyunryu/koscrap\")\n\n\n\n\n소품(Vignettes)은 비네트라고 발음합니다. 패키지의 기능을 소개하는 짧은 문서를 의미합니다. 함수의 도움말보다는 규모가 큽니다.↩︎\n",
      "last_modified": "2022-02-11T23:02:20+09:00"
    },
    {
      "path": "docker_resources.html",
      "title": "학습 리소스",
      "description": "**docker를 이해하고, docker 기반으로 데이터분석 서비스 구축**에 대한 학습 리소스\n",
      "author": [],
      "contents": "\n\nContents\ndocker 학습과 개발을 위한 리소스\ndocker 학습을 위한 리소스\nR 기반의 환경을 위한 docker 리소스\n\n\ndocker 학습과 개발을 위한 리소스\ndocker 학습을 위한 리소스\ndocker 홈페이지 :\nhttps://www.docker.com/\ndocker 홈페이지로 제품, 블로그 등 docker 관련 정보 보유\n\nHOSTING 홈페이지 :\nhttps://hosting.analythium.io/\ndocker Shiny 서버 기반으로 웹 호스팅을 수행한 많은 유용한 정보가 있는 사이트\n\ncovidapp-shiny github 페이지 :\nhttps://github.com/analythium/covidapp-shiny\ndocker 기반의 Shiny 애플리케이션을 구축한 사례\n\nR 기반의 환경을 위한 docker 리소스\ndocker hub 홈페이지 :\nhttps://hub.docker.com/\ndocker에서 운영하는 docker 이미지 저장소 서비스 사이트\n이미지를 직접 올리려는 게 아니면 회원가입을 할 필요는 없음\n\nroker github 페이지 :\nhttps://github.com/rocker-org/rocker-versioned2\nVersion-stable Rocker images for R >= 4.0.0\n\n\n\n\n",
      "last_modified": "2022-02-11T23:02:20+09:00"
    },
    {
      "path": "index.html",
      "title": "R 워크샾 개요",
      "description": "본 R 워크샾은 정기적으로 데이터를 수집하고 이를 Shiny 서버를 통해서 통계 어플리케이션 서비스를 제공하는 방법을 익히는 것을 목적으로 합니다. \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2022-02-02",
      "contents": "\n\nContents\n워크샾 일정\n워크샾 내용\n\n워크샾 일정\n일시:\n2022-02-12 10:00 ~ 12:00, 13:00 ~ 15:00\n\n장소:\nZoom 온라인\n\n워크샾 내용\ndistill 패키지의 활용\n아젠다\nR Markdown의 이해\ndistill 패키지를 이용한 웹 사이트의 구축\n\n목적\n재현가능한 연구나 개인과 조직의 Knowledge Base 구축의 자신감 고취하기\n\n\n데이터 수집을 위한 패키지 개발\n아젠다\nOpen API를 이용한 데이터 수집 로직 구현\n데이터 수집 로직을 위한 R 패키지 개발\n\n목적\nOpen API 기반 데이터 수집의 이해와 패키지 개발을 위한 기초 지식 확보하기\n\n\nShiny 애플리케이션 개발의 ABC\n아젠다\nShiny 애플리케이션의 이해\n간단한 애플리케이션 개발하기\n\n목적\n수집한 데이터의 통계 분석을 위한 Shiny 애플리케이션 개발의 여정 지원하기\n\n\ndocker 기반의 Shiny 서버 구축\n아젠다\ndocker 기반의 Shiny 서버 구축\ndocker 환경에서의 스케줄링을 통한 데이터 수집\n\n목적\nShiny 서버를 구축하고, 서비스를 위한 데이터 수집 자동화 설정 방법 이해하기\n\n\n",
      "last_modified": "2022-02-11T23:02:21+09:00"
    },
    {
      "path": "install_docker_image.html",
      "title": "docker 이미지 설치하기",
      "description": "docker 기반으로 Shiny 서버를 운영하기 위한 기초작업을 수행합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2022-01-16",
      "contents": "\n\nContents\nShiny 서버를 사용하는 이유\nShiny 서버 설치하기\ndocker 이미지 가져오기\nShiny 서버 실행하기\n\n결언\n\n\n\n\n\n\n\n들어가기\nShiny 서버 docker 이미지를 설치하여, 컨테이너를 구동하는 방법을 설명합니다.\n\ndocker가 설치된 환경을 전제로 설명합니다. docker 환경 구축하는 방법은 다루지 않습니다.\n\n\n\nShiny 서버를 사용하는 이유\nRStudio에서 Shiny 애플리케이션을 실행하면 애플리케이션을 종료하기 전까지 RStudio를 사용할 수 없습니다. 그러나 Shiny 서버에서 Shiny 애플리케이션을 구동하면, 언제든지 웹 브라우저에서 애플리케이션을 실행할 수 있고 RStudio는 애플리케이션의 구동과 독립적으로 사용할 수 있습니다.\nShiny 서버를 사용하는 이유에서 눈치챘겠지만, 이 글은 Shiny 애플리케이션을 호스팅할 목적의 작업이라기 보다는 개인 노트북에 Shiny 애플리케이션 데모 환경을 구축하기 위함입니다. 그러나 Shiny 애플리케이션을 호스팅할 목적으로도 활용할 수 있습니다.\nShiny 서버 설치하기\ndocker 이미지 가져오기\nShiny 서버의 운영을 위해서 rocker/shiny-verse 이미지를 가져옵니다. 이 이미지는 Shiny 이미지와 Tidyverse 패키지를 포함하고 있습니다.\nrocker/shiny + rocker/shiny-verse\n다음 명령으로 docker hub 저장소로부터 docker 이미지를 가져옵니다.\n\npull rocker/shiny-verse\n\n이미지 목록에서 가져온 Shiny 이미지를 확인할 수 있습니다.\n\ndocker images \n\nShiny 서버 실행하기\n다음 run 명령으로 docker 컨테이너를 생성하고 실행합니다. 즉, Shiny 서버를 실행합니다.\n\ndocker run --rm -p 3838:3838 rocker/shiny-verse\n\n서버가 실행되면, http://localhost:3838 URL에서 Shiny 데모 애플리케이션을 실행할 수 있습니다.\nShiny 데모 애플리케이션결언\ndocker 컨테이너로 Shiny 데모 애플리케이션을 구동할 수 있습니다. 그러나 아직은 사용자가 개발한 애플리케이션을 구동하기 위한 docker 환경은 아닙니다. 추가적인 환경 설정이 필요해 보입니다.\n\n\n\n",
      "last_modified": "2022-02-11T23:02:22+09:00"
    },
    {
      "path": "introduce_shiny.html",
      "title": "Shiny 아키텍처 이해",
      "description": "Shiny 아키텍처를 이해합니다. **UI**, **server**, **입력 위젯(input widget)**, **출력 위젯(output widget)**, **렌더링(Rendering)** 정도는 숙지해야 합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-05",
      "contents": "\n\nContents\nShiny 아키텍처\nUI와 Server의 상호작용\nUI와 server의 상호작용 예시\nUI와 server의 상호작용 표준화\n\nShiny 첫 예제\n히스토그램 그리기 예제\n예제 실행해 보기\n\ntutorial\nShiny 공식 tutorial 페이지\n\n\n\n\n\n\n\n들어가기\n본 핸즈온(튜토리얼)은\nShiny를 이해하려는 대상의 OJT를 염두로\n작성되었습니다. 초심자 대상이기 때문에, Shiny의 ABC만   \n     다룹니다. 그 이상의 학습을 원하는 분들은\nResouces\n페이지를 참고하십시요.\n\n학습 내용은\nShiny in seven lessons\n(\nhttps://shiny.rstudio.com/tutorial/\n) 을 참조하여 작성하였습니다.\n\n\nShiny 아키텍처\nUI와 Server의 상호작용\nUI와 Server의 상호작용UI : 사용자 인터페이스(User Interface) 영역으로 입력 위젯(input widget)을 통해 사용자가 의도하는 파라미터(인수)를 server에 전달합니다.\nserver : 입력 위젯의 변화를 감지하여, 미리 정의된 작업을 수행한 후 그 결과를 출력 위젯(output widget)에 렌더링하여(rendering) 사용자에게 전달합니다.\nUI와 server의 상호작용 예시\nUI와 Server의 상호작용 예시sliderInput 위젯은 사용자 입력을 기다리고,\n입력 위젯(input widget)은 사용자의 입력을 대기\n\n입력을 인지한 후, sliderInput 위젯과 연결된 renderPlot() 함수를 호출\n위젯이 변경되면 변경된 위젯이 포함된 렌더링 함수가 자동 호출됩니다.\n\nrenderPlot() 함수는 sliderInput 위젯 값만큼의 막대가 포함된 히스토그램을 그리고,\n렌더링 함수가 실행됩니다.\n\n히스토그램은 출력 위젯(Output widget)인 plotOutput에 렌더링(그려짐)됩니다.\n출력 위젯에 렌더링된 결과가 반영됩니다.\n\nUI와 server의 상호작용 표준화\nUI와 server의 상호작용을 shiny 스크립트 관점에서 표준화해 봅니다.\n위젯들은 개별 위젯을 인식하도록 아이디를 부여해야 합니다.\n입력 위젯은 inputId,\n출력 위젯은 outputId\n\n입력 위젯의 이름은 “기능명 + Input” 포맷으로 정의됩니다.\nsliderInput = slider + Input,\n즉, 슬라이더로 사용자 입력을 받아서 서버로 전달하는 위젯\n\n출력 위젯의 이름은 “기능명 + Output” 포맷으로 정의됩니다.\nplotOutput = plot + Output,\n즉, 시각화된 R 플롯을 출력하는 위젯\n\n렌더링 함수 이름은 “render + 기능명” 포맷으로 정의됩니다.\nrenderPlot = render + Plot,\n즉, 플롯으로 렌더링하는(플롯을 그리는) 함수\n\nShiny 첫 예제\n히스토그램 그리기 예제\nUI와 Server의 상호작용 예시를 구현한 shiny 프로그램은 다음과 같습니다.\n눈으로 한번 쭉 훑어보세요. 이해할 것 같으면서도 어려운 겁니다.\n\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui <- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n\n    output$distPlot <- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    <- faithful[, 2]\n        bins <- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n\n\n예제 실행해 보기\n아키텍처를 이해하려는 목적으로 결과를 보고 프로그램도 살펴 보세요.\n\n\nshiny::runExample(\"01_hello\")\n\n\n\ntutorial\nShiny 공식 tutorial 페이지\nShiny 공식 tutorial 페이지를 살펴보고, 앱을 실행시키는 방법을 숙지하세요.\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson1/\n\n\n\n",
      "last_modified": "2022-02-11T23:02:22+09:00"
    },
    {
      "path": "news_app.html",
      "title": "네이버 뉴스 검색 애플리케이션",
      "description": "간단한 애플리케이션을 만들어 봅니다. **koscrap** 패키지를 이용해서 **네이버 뉴스 검색 애플리케이션**을 만듭니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-06",
      "contents": "\n\nContents\n애플리케이션 설계\n기능 설계\n사용자 인터페이스 설계\n\n애플리케이션 코드\nUI Side\nServer Side\n사용 패키지 및 애플리케이션 호출\n사용 패키지\n애플리케이션 호출\n\n\n애플리케이션 실행\n애플리케이션 실행 화면\n\n\n\n\n\n\n\n들어가기\n공격이 최선의 방어라는 격투기 격언이 있습니다. Shiny의 경우는\n실제로 애플리케이션을 개발해 보는 것이 최선의 학습\n입니다.\n\n간단하지만, 유용한 애플리케이션을 만들어 볼까요? 걱정할 필요 없습니다. 천천히 따라오세요\n\n\n애플리케이션 설계\n기능 설계\n네이버 뉴스 검색 애플리케이션의 기능은 다음과 같이 정의합니다.\n입력 기능\n사용자 인증을 위한 Client ID, Client Secret 입력\n검색하려는 뉴스 키워드 입력\n정렬 옵션 선택\n날짜순 정렬\n유사도순 정렬\n\n검색건수 입력\n\n출력 기능\n검색 뉴스 테이블 출력\n타이틀\n뉴스내용 요약\n뉴스 게시시간\n뉴스 링크\n하이퍼링크를 걸어서, 클릭하면 해당 브라우저 창을 열어 뉴스화면 이동\n\n\n\n사용자 인터페이스 설계\n페이지\nfluidPage\n\n레이아웃\nsidebarLayout\n\n패널\nsidebarPanel\n입력 위젯 위치\n\nmainPanel\n출력 위젯 위치\n\n\n입력 위젯\ntextInput\nClient ID, Client Secret, 검색 키워드\n\nradioButtons\n정렬 옵션 선택\n\nsliderInput\n검색건수\n\nactionButton\n뉴스 검색 버튼\n\n\n출력 위젯\nreactable\n검색 결과 출력\n\n\n애플리케이션 코드\nUI Side\n\n\n# UI Side\nui <- fluidPage(\n    # Application title\n    titlePanel(\"네이버 뉴스 검색 애플리케이션\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            textInput(\"client_id\", \n                      label = h4(\"Client ID:\"), \n                      value = \"\"),\n            textInput(\"client_secret\", \n                      label = h4(\"Client Secret:\"), \n                      value = \"\"),            \n            textInput(\"keyword\", \n                      label = h4(\"검색 키워드:\"), \n                      value = \"\"),\n            radioButtons(\"sort\", label = h4(\"정렬 옵션:\"),\n                         choices = list(\"날짜순\" = \"date\", \"유사도순\" = \"sim\"), \n                         selected = \"date\"),           \n            sliderInput(\"max_record\", label = h4(\"검색 건수:\"), min = 0, \n                        max = 500, value = 100),\n            actionButton(\"search_keyword\", label = \"뉴스 검색\", \n                         icon = icon(\"newspaper\")),\n            width = 3\n        ),\n\n        # Reactable에 검색 결과 리스트업\n        mainPanel(\n            reactableOutput(\"news_list\"),\n            width = 9\n        )\n    )\n)\n\n\n\nServer Side\n\n\n# Server Side\nserver <- function(input, output) {\n    output$news_list <- renderReactable({\n        # 뉴스 검색 리스트의 초기화 출력\n        init_data <- data.frame(\n            title = character(0),\n            description = character(0),\n            publish_date = character(0),\n            link = character(0),\n            stringsAsFactors = FALSE\n        )\n        \n        reactable(\n            init_data,\n            defaultColDef = colDef(\n                align = \"left\"\n            ),\n            columns = list(\n                title = colDef(\n                    name = \"타이틀\",\n                    width = 250,\n                ),\n                description = colDef(name = \"뉴스내용 요약\"),\n                publish_date = colDef(\n                    name = \"뉴스 계시시간\",\n                    width = 150,\n                ),\n                link = colDef(\n                    name = \"뉴스 링크\",\n                    width = 250#,\n                    # cell = function(value) {\n                    #     print(value)\n                    #     cat(value)\n                    #     htmltools::tags$a(href = value, target = \"_blank\", value)\n                    # }\n                )    \n            ),\n            showPageSizeOptions = TRUE,\n            pageSizeOptions = c(5, 10, 15), \n            defaultPageSize = 5,\n            bordered = TRUE,\n            highlight = TRUE\n        )\n    })\n    \n    observeEvent(input$search_keyword, {\n        # 3개의 텍스트는 반드시 입력해야 함\n        req(input$keyword)\n        req(input$client_id)\n        req(input$client_secret)\n        \n        # 네이버 오픈 API 호출\n        search_list <- koscrap::search_naver(\n            query = input$keyword, \n            sort  = input$sort,\n            chunk = min(input$max_record, 100),\n            max_record = input$max_record,\n            do_done = TRUE,\n            client_id = input$client_id, \n            client_secret = input$client_secret) %>%\n            mutate(title = title_text) %>% \n            mutate(description = description_text) %>% \n            mutate(publish_date = stringr::str_remove_all(publish_date, \n                                                          \"[[:alpha:]]\")) %>% \n            select(title, description, publish_date, link)\n            \n        updateReactable(\"news_list\", \n                        data = search_list)\n    })\n}\n\n\n\n사용 패키지 및 애플리케이션 호출\n사용 패키지\n\n\nlibrary(\"shiny\")\nlibrary(\"dplyr\")\nlibrary(\"koscrap\")\nlibrary(\"reactable\")\nlibrary(\"htmltools\")\n\n\n\n애플리케이션 호출\n\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n\n\n애플리케이션 실행\n애플리케이션 실행 화면\n애플리케이션을 실행하면 다음과 같의 화면을 얻을 수 있습니다.\n네이버 뉴스 검색 애플리케이션\n\n\n",
      "last_modified": "2022-02-11T23:02:27+09:00"
    },
    {
      "path": "open_api.html",
      "title": "네이버 오픈 API를 이용한 데이터 수집",
      "description": "네이버 오픈 API를 이용한 데이터 수집 로직을 구현해 봅니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-02",
      "contents": "\n\nContents\n오픈 API\n대상 API\n네이버 뉴스 검색\nAPI 기본 정보\n요청 변수 (request parameter)\n출력 결과\n준비사항\n\n네이버 뉴스 검색 프로그램 개발\n요청 URL 생성\nAPI 호출\nXML 파싱\n다건 처리 로직\n함수의 완성\n함수의 호출\n\n\n\n\n\n\n\n들어가기\n공공 데이터 및 기업의 인터넷 서비스의 다수가 오픈 API를 통해서 관련 데이터를 제공합니다.\n\n이제는 데이터 수집을 위해서 오픈 API를 이용할 수 있는 기술을 습득해야 합니다.\n\n이제 여러분은 NAVER의 오픈 API를 다룰 수 있게 됩니다.\n\n\n오픈 API\n오픈 API(Open Application Programming Interface, Open API, 공개 API) 또는 공개 API는 개발자라면 누구나 사용할 수 있도록 공개된 API를 말하며, 개발자에게 사유 응용 소프트웨어나 웹 서비스의 프로그래밍 적인 권한을 제공합니다.1\n\n\n\n\n수년 전만해도 공동 데이터의 수집과 NAVER 웹 페이지의 데이터를 수집하기 위해서는 웹 페이지를 핸들링하는 기술을 통해서 데이터를 Scraping 해야 했습니다. 그러나 이제는 해당 기관과 업체에서 오픈 API를 제공하기 때문에, 합법적인 방법으로 원하는 데이터를 수집할 수 있는 세상이 되었습니다.\n대상 API\n네이버 뉴스 검색\n네이버\n\n아파트 실거래 데이터 가져오기\n공공 데이터 포털\n\n네이버 뉴스 검색\n네이버 뉴스 검색 결과를 출력해주는 REST API를 이용해서 뉴스 데이터를 수집합니다. Documents > 서비스 API > 검색 > 뉴스에 해당 API에 대한 스팩이 설명되어 있습니다.\nAPI 기본 정보\n다음과 같은 두 가지의 API가 있습니다. 여기서는 출력 포맷이 XML인 API를 이용합니다.\n메서드\n인증\n요청 URL\n출력 포맷\nGET\n-\nhttps://openapi.naver.com/v1/search/news.xml\nXML\nGET\n-\nhttps://openapi.naver.com/v1/search/news.json\nJSON\n요청 변수 (request parameter)\n요청 변수\n타입\n필수여부\n기본값\n설명\nquery\nstring\nY\n-\n검색을 원하는 문자열로서 UTF-8로 인코딩\ndisplay\ninteger\nN\n10(기본값), 100(최대)\n검색 결과 출력 건수 지정\nstart\ninteger\nN\n1(기본값), 1000(최대)\n검색 시작 위치로 최대 1000까지 가능\nsort\nstring\nN\nsim, date(기본값)\n정렬 옵션: sim (유사도순), date (날짜순)\n출력 결과\n필드\n타입\n설명\nrss\n-\n디버그를 쉽게 하고 RSS 리더기만으로 이용할 수 있게 하기 위해 만든 RSS 포맷의 컨테이너이며 그 외의 특별한 의미는 없다.\nchannel\n-\n검색 결과를 포함하는 컨테이너이다. 이 안에 있는 title, link, description 등의 항목은 참고용으로 무시해도 무방하다.\nlastBuildDate\ndatetime\n검색 결과를 생성한 시간이다.\ntotal\ninteger\n검색 결과 문서의 총 개수를 의미한다.\nstart\ninteger\n검색 결과 문서 중, 문서의 시작점을 의미한다.\ndisplay\ninteger\n검색된 검색 결과의 개수이다.\nitem/items\n-\nXML 포멧에서는 item 태그로, JSON 포멧에서는 items 속성으로 표현된다. 개별 검색 결과이며 title, originallink, link, description, pubDate를 포함한다.\ntitle\nstring\n개별 검색 결과이며, title, originallink, link, description, pubDate 를 포함한다.\noriginallink\nstring\n검색 결과 문서의 제공 언론사 하이퍼텍스트 link를 나타낸다.\nlink\nstring\n검색 결과 문서의 제공 네이버 하이퍼텍스트 link를 나타낸다.\ndescription\nstring\n검색 결과 문서의 내용을 요약한 패시지 정보이다. 문서 전체의 내용은 link를 따라가면 읽을 수 있다. 패시지에서 검색어와 일치하는 부분은 태그로 감싸져 있다.\npubDate\ndatetime\n검색 결과 문서가 네이버에 제공된 시간이다.\n준비사항\n애플리케이션 등록: 네이버 오픈 API로 개발하시려면 먼저 ‘Application-애플리케이션 등록’ 메뉴에서 애플리케이션을 등록하셔야 합니다.\n\n\n\nFigure 1: 애플리케이션 등록 (API 이용신청) 화면\n\n\n\n클라이언트 ID와 secret 확인: ‘내 애플리케이션’에서 등록한 애플리케이션을 선택하면 Client ID와 Client Secret 값을 확인할 수 있습니다.\n\n\n\nFigure 2: 애플리케이션 정보 화면\n\n\n\n이 화면은 중요한 정보를 보여줍니다. 하루에 검색 API 호출이 25000회로 제한되어 있습니다.\n\n\n\n\n주의\n\n클라이언트 아이디(Client ID)와  클라이언트 보안키(Client Secret)는 개인 사용자에게 발급된 정보이므로 반드시 보안에 주의해야 합니다. 타인에게 공개 및 공유하면 안된 중요한 정보이므로 사용에 주의해야 합니다.\n\n\n네이버 뉴스 검색 프로그램 개발\n요청 URL 생성\nXML 출력 포맷을 사용하기 때문에 다음 요청 URL을 사용합니다.\nhttps://openapi.naver.com/v1/search/news.xml\n검색 질의어인 query는 UTF-8로 인코딩해야 하기 때문에 enc2utf8()와 URLencode()을 사용합니다. GET 방식의 호출 URL이기 때문에 요청변수 영역을 ?로 구분하고, 요청 변수들은 &로 구분합니다.\n\n\n  searchUrl <- \"https://openapi.naver.com/v1/search/news.xml\"\n\n  query <- query %>%\n    enc2utf8() %>%\n    URLencode()\n\n  url <- glue::glue(\"{searchUrl}?query={query}&display={chunk}&start={chunk_no}&sort={sort}\")\n\n\n\nAPI 호출\nGET으로 호출할 때 HTTP Header에 애플리케이션 등록 시 발급받은 Client ID와 Client Secret 값을 같이 전송해야 합니다. 그러므로 httr 패키지를 사용합니다.\n\n\n  doc <- url %>%\n    httr::GET(\n      httr::add_headers(\n        \"X-Naver-Client-Id\"     = client_id,\n        \"X-Naver-Client-Secret\" = client_secret\n      )\n    ) %>%\n    toString() %>%\n    XML::xmlParse()\n\n\n\nXML 파싱\n키워드로 검색된 뉴스의 건수를 가져옵니다. 아마도 많은 경우는 대체로 많은 건수의 뉴스가 검색될 것입니다. 검색 결과 문서의 총 개수를 의미하는 total 노드를 가져다가 정수로 변환합니다.\n\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//total\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n\n\nXML 포멧에서는 item 태그로 개별 검색 결과를 반환합니다. 역시 getNodeSet()로 item 노드를 가져다 조작합니다. xmlToDataFrame()가 이들 개별 결과들을 데이터 프레임 객체로 변환합니다.\n그리고 다음과 같은 데이터 변환을 수행합니다.\npubDate:\n날짜-시간을 표현하는 POSIXct 객체로 변환\n\ntitle:\nHTML 태그 들을 제거한 텍스트 생성하여,\ntitle_text 변수 파생\n\ndescription:\nHTML 태그 들을 제거한 텍스트 생성하여,\ndescription_text 변수 파생\n\n\n\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      rename(\"publish_date\" = pubDate) %>%\n      mutate(publish_date = as.POSIXct(publish_date,\n                                       format = \"%a, %d %b %Y %H:%M:%S %z\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title, \"&\\\\w+;|<[[:punct:]]*b>\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title_text, \"[[:punct:]]*\")) %>%\n      mutate(description_text = stringr::str_remove_all(\n        description,\n        \"&\\\\w+;|<[[:punct:]]*b>|[“”]\"))\n\n\n\n다건 처리 로직\n요청 변수의 display는 API 호출에서 가져올 결과의 건수입니다. 한번 호출에 최대 100건까지 가져올 수 있습니다. 그러므로 검색 결과가 100건이 넘는 경우에는 여러번 호출을 통해서 해당하는 모든 건을 가져올 수 있습니다. 이 경우 검색 시작 위치인 start로 분할해서 가져올 페이지 번호를 지정할 수 있습니다. 만약 100건을 가져왔다면 다음 호출의 start는 101이어야 합니다.\nstart의 최대값은 1000으로 제한되어 있습니다. 그러므로 API로 가져올 수 있는 뉴스의 개별 결과는 100,000건입니다.\nMax(start) * Max(display) = 1000 * 100 = 100,000\n\n\n\n\n주의\n\nR은 눈사람을 만드는 것처럼 데이터를 키워나가면 안됩니다.\n\nrbind() 함수를 이용해서 API를 순차적으로 호출하면서 데이터 프레임에 결과를 붙여나가면 안됩니다. R 데이터 프레임에 관측치를 붙여나가면서 데이터를 크게 불리는 작업은 치명적인 성능 감소를 가져옵니다.\n\n\n다음은 chunk 사이즈보다 큰 다건의 검색 결과 처리를 위한 로직입니다.\npurrr 패키지의 map_df()의 프로그래밍 함수를 이용해서, 여러 번 API를 호출합니다. 이 로직은 주의에서 언급한 방법을 회피하는 로직입니다.\n\n\n  search_list <- doc %>%\n    get_list()\n\n  records <- NROW(search_list)\n\n  if (!do_done | records >= total_count | records >= max_record) {\n    return(search_list)\n  } else {\n    total_count <- min(total_count, max_record)\n\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    idx <- (seq(cnt) + 1)\n\n    add_list <- idx[idx <= 1000] %>%\n      purrr::map_df({\n        function(x) {\n          if (verbose) {\n            glue::glue(\"  - ({chunk * x}/{total_count})건 호출을 진행합니다.\\n\\n\") %>%\n              cat()\n          }\n\n          glue::glue(\n            \"{searchUrl}?query={query}&display={chunk}&start={x}&sort={sort}\"\n          ) %>%\n            httr::GET(\n              httr::add_headers(\n                \"X-Naver-Client-Id\"     = client_id,\n                \"X-Naver-Client-Secret\" = client_secret\n              )\n            ) %>%\n            toString() %>%\n            XML::xmlParse() %>%\n            get_list()\n        }\n      })\n\n    search_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n\n\n\n함수의 완성\n이상의 로직을 통합해서 네이버 뉴스를 검색하는 함수를 다음과 같이 정의하였습니다.\n\n\nsearch_naver <- function(query = NULL, chunk = 100, chunk_no = 1,\n                         sort = c(\"date\", \"sim\"), do_done = FALSE,\n                         max_record = 1000L, client_id = NULL,\n                         client_secret = NULL, verbose = TRUE) {\n  if (is.null(query)) {\n    stop(\"검색 키워드인 query를 입력하지 않았습니다.\")\n  }\n\n  if (chunk < 1 & chunk > 100) {\n    stop(\"chunk 요청 변수값이 허용 범위(1~100)인지 확인해 보세요.\")\n  }\n\n  if (chunk_no < 1 & chunk_no > 100) {\n    stop(\"chunk_no 요청 변수값이 허용 범위(1~1000)인지 확인해 보세요.\")\n  }\n\n  sort <- match.arg(sort)\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      rename(\"publish_date\" = pubDate) %>%\n      mutate(publish_date = as.POSIXct(publish_date,\n                                       format = \"%a, %d %b %Y %H:%M:%S %z\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title, \"&\\\\w+;|<[[:punct:]]*b>\")) %>%\n      mutate(title_text = stringr::str_remove_all(\n        title_text, \"[[:punct:]]*\")) %>%\n      mutate(description_text = stringr::str_remove_all(\n        description,\n        \"&\\\\w+;|<[[:punct:]]*b>|[“”]\"))\n  }\n\n  searchUrl <- \"https://openapi.naver.com/v1/search/news.xml\"\n\n  query <- query %>%\n    enc2utf8() %>%\n    URLencode()\n\n  url <- glue::glue(\"{searchUrl}?query={query}&display={chunk}&start={chunk_no}&sort={sort}\")\n\n  doc <- url %>%\n    httr::GET(\n      httr::add_headers(\n        \"X-Naver-Client-Id\"     = client_id,\n        \"X-Naver-Client-Secret\" = client_secret\n      )\n    ) %>%\n    toString() %>%\n    XML::xmlParse()\n\n  total_count <- doc %>%\n    XML::getNodeSet(\"//total\") %>%\n    XML::xmlValue() %>%\n    as.integer()\n\n  if (verbose) {\n    glue::glue(\"* 검색된 총 기사 건수는 {total_count}건입니다.\\n\\n\") %>%\n      cat()\n\n    glue::glue(\"  - ({chunk}/{min(total_count, max_record)})건 호출을 진행합니다.\\n\\n\") %>%\n      cat()\n  }\n\n  search_list <- doc %>%\n    get_list()\n\n  records <- NROW(search_list)\n\n  if (!do_done | records >= total_count | records >= max_record) {\n    return(search_list)\n  } else {\n    total_count <- min(total_count, max_record)\n\n    cnt <- total_count %/% chunk\n    if (total_count %% chunk == 0) {\n      cnt <- cnt - 1\n    }\n\n    idx <- (seq(cnt) + 1)\n\n    add_list <- idx[idx <= 1000] %>%\n      purrr::map_df({\n        function(x) {\n          if (verbose) {\n            glue::glue(\"  - ({chunk * x}/{total_count})건 호출을 진행합니다.\\n\\n\") %>%\n              cat()\n          }\n\n          glue::glue(\n            \"{searchUrl}?query={query}&display={chunk}&start={x}&sort={sort}\"\n          ) %>%\n            httr::GET(\n              httr::add_headers(\n                \"X-Naver-Client-Id\"     = client_id,\n                \"X-Naver-Client-Secret\" = client_secret\n              )\n            ) %>%\n            toString() %>%\n            XML::xmlParse() %>%\n            get_list()\n        }\n      })\n\n    search_list %>%\n      bind_rows(\n        add_list\n      ) %>%\n      return()\n  }\n}\n\n\n\n함수의 호출\n다음은 불평등이라는 단어가 포함된 네이버 뉴스를 검색하는 예제입니다. 실행하면 100건의 결과를 가져옵니다.\n\n\n# Your authorized API keys\nclient_id <- \"XXXXXXXXXXXXXXXXXXXXXXX\"\nclient_secret <- \"XXXXXXXXX\"\n\nsearch_list <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret\n)\n\n\n\n다음은 불평등이라는 단어가 포함된 네이버 뉴스를 검색하는 예제입니다. 총 3000건의 결과를 가져옵니다. 그러므로 함수 내부에서 30번의 API 호출이 이루어집니다.\n\n\nsearch_list <- search_naver(\n  \"불평등\", client_id = client_id, client_secret = client_secret,\n  do_done = TRUE, max_record = 3000\n)\n\n\n\n\n출처: https://ko.wikipedia.org/wiki/오픈_API↩︎\n",
      "last_modified": "2022-02-11T23:02:28+09:00"
    },
    {
      "path": "package_resources.html",
      "title": "학습 리소스",
      "description": "R 패키지를 생성하고 유지보수하는데 도움일 되는 R 패키지 관련 학습 리소스  \n",
      "author": [],
      "contents": "\n\nContents\nR 패키지 관련 기술 학습을 위한 리소스\nR 패키지 학습을 위한 리소스\nR 패키지 관련 Youtube 리소스\n\n\nR 패키지 관련 기술 학습을 위한 리소스\nR 패키지 학습을 위한 리소스\nR Packages 홈페이지 :\nhttps://r-pkgs.org/index.html\nHadley Wickham의 R Packages Second edition\n\nR 패키지 관련 Youtube 리소스\nCreating Your First R Package in 2 Minutes in RStudio :\nhttps://www.youtube.com/watch?v=47PN2VG3RmI\nCreating Your First R Package in 2 Minutes in RStudio!\n\nWhy and how to build an R package:\nhttps://www.youtube.com/watch?v=qmTaAIEXxSQ\nWhy and how to build an R package\n\nYour first R package in 1 hour :\nhttps://www.youtube.com/watch?v=xcXzaEmZ-m4\n“Your first R package in 1 hour: Tools that make R package development easy” with Shannon Pileggi\n\n",
      "last_modified": "2022-02-11T23:02:29+09:00"
    },
    {
      "path": "reactivity.html",
      "title": "반응 출력",
      "description": "반응 출력을 이해합니다. **랜더링 함수**의 종류와 기능도 숙지해야 합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-05",
      "contents": "\n\nContents\n반응형 출력을 아시나요?\n출력 위젯\nUI에 출력 위젯 추가하기\n\n렌더링 함수\n렌더링 함수로 결과 반환하기\n\n\ntutorial\n반응 출력 완성하기 tutorial\ntutorial 페이지\n추가 예제 실행해 보기\n\n\n\n\n\n\n\n들어가기\n의도를 파악하자마자 바로 전달합니다.\n반응출력이라 하지요.\n\n어렵지 않습니다. 유저 인터페이스를 통한 커뮤니케이션에서 화자인 의도에 대해서 그저 어떤 방식으로 반응(랜더링)할지 정하면 됩니다.\n\n\n반응형 출력을 아시나요?\n“반응형 출력(reactive output)은 사용자가 입력 위젯의 값을 변경하면, 이에 반응, 응답하여 출력을 자동으로 만들어주는 것을 의미합니다.” 일반적인 웹 어플리케이션은 사용자가 입력 위젯의 값을 변경한 후, “확인”, “실행” 등의 버튼을 누를 때 출력이 발생하지만, Shiny는 기본적으로 반응형 출력으로 결과를 반환합니다.\n출력 위젯\n출력 위젯의 이름의 접미사는 “Output”로 계산된 결과나 시각화 결과를 사용자에게 보여주는 기능을 수행합니다.\nshiny 패키지의 출력 위젯은 같습니다.\n\n\nlibrary(shiny)\n\nls(pos = \"package:shiny\", pattern = \"Output$\")\n\n\n[1] \"dataTableOutput\"          \"htmlOutput\"              \n[3] \"imageOutput\"              \"plotOutput\"              \n[5] \"snapshotPreprocessOutput\" \"tableOutput\"             \n[7] \"textOutput\"               \"uiOutput\"                \n[9] \"verbatimTextOutput\"      \n\nUI에 출력 위젯 추가하기\n“selected_var”라는 아이디로 출력 위젯 textOutput을 UI에 추가합니다.\n\n\nui <- fluidPage(\n  titlePanel(\"censusVis\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Create demographic maps with \n               information from the 2010 US Census.\"),\n      \n      selectInput(\"var\", \n                  label = \"Choose a variable to display\",\n                  choices = c(\"Percent White\", \n                              \"Percent Black\",\n                              \"Percent Hispanic\", \n                              \"Percent Asian\"),\n                  selected = \"Percent White\"),\n      \n      sliderInput(\"range\", \n                  label = \"Range of interest:\",\n                  min = 0, max = 100, value = c(0, 100))\n    ),\n    \n    mainPanel(\n      textOutput(\"selected_var\")\n    )\n  )\n)\n\n\n\n렌더링 함수\n렌더링 함수 이름의 접두사는 “render”로 입력 위젯의 값이 변경되면 반응하여 계산 결과를 출력 위젯에 랜더링합니다.\nshiny 패키지의 렌더링 함수는 다음과 같습니다.\n\n\nls(pos = \"package:shiny\", pattern = \"^render\")\n\n\n[1] \"renderCachedPlot\" \"renderDataTable\"  \"renderImage\"     \n[4] \"renderPlot\"       \"renderPrint\"      \"renderTable\"     \n[7] \"renderText\"       \"renderUI\"        \n\n렌더링 함수\n생성 객체\n내용\nrenderDataTable\nDataTable\n데이터 테이블\nrenderImage\n이미지\n이미지 파일 등\nrenderPlot\n플롯\n플롯 결과\nrenderPrint\n텍스트 출력\n모든 출력\nrenderTable\n테이블 구조 객체\ndata frame, matrix 등\nrenderText\n텍스트 출력\n텍스트 출력\nrenderUI\n사용저 정의 UI\n기존 위젯으로 사용자가 정의한 위젯\n렌더링 함수로 결과 반환하기\n다음 예제는 렌더링 함수인 renderText로 아이디가 “selected_var”인 출력 위젯에 “You have selected this”라는 텍스트를 렌더링(출력)합니다. 그러나 이것은 반응 출력이 아닙니다.\n\n\nserver <- function(input, output) {\n  output$selected_var <- renderText({ \n    \"You have selected this\"\n  })\n}\n\n\n\n다음 예제는 렌더링 함수인 renderText로 아이디가 “selected_var”인 출력 위젯에 “You have selected this”라는 텍스트와 아이디가 “var”인 입력 위젯의 값을 붙여서 렌더링(출력)합니다.\n이것은 반응 출력이 입니다. 렌더링 함수에 포함된 입력 위젯인 “var”의 값이 변경될 때마다 renderText 함수가 반응하여 계산된 결과를 출력 위젯인 “selected_var”에 렌더링합니다.\ninput$var는 아이디가 “var”인 입력 위젯을 의미하고, output$selected_var는 아이디가 “selected_var”인 출력 위젯을 의미합니다.\n\n\nserver <- function(input, output) {\n  output$selected_var <- renderText({ \n    paste(\"You have selected\", input$var)\n  })\n}\n\n\n\ntutorial\n반응 출력 완성하기 tutorial\n다음 코드를 입력한 후, app.R이라는 이름의 파일로 저장하고 실행해 보세요. 완성된 반응 출력의 기능을 확인할 수 있습니다. 여러분은 server 파트를 완성하였습니다.\n\n\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"censusVis\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Create demographic maps with \n               information from the 2010 US Census.\"),\n      \n      selectInput(\"var\", \n                  label = \"Choose a variable to display\",\n                  choices = c(\"Percent White\", \n                              \"Percent Black\",\n                              \"Percent Hispanic\", \n                              \"Percent Asian\"),\n                  selected = \"Percent White\"),\n      \n      sliderInput(\"range\", \n                  label = \"Range of interest:\",\n                  min = 0, max = 100, value = c(0, 100))\n    ),\n    \n    mainPanel(\n      textOutput(\"selected_var\"),\n      textOutput(\"min_max\")\n    )\n  )\n)\n\nserver <- function(input, output) {\n  \n  output$selected_var <- renderText({ \n    paste(\"You have selected\", input$var)\n  })\n  \n  output$min_max <- renderText({ \n    paste(\"You have chosen a range that goes from\",\n          input$range[1], \"to\", input$range[2])\n  })\n  \n}\n\nshinyApp(ui, server)\n\n\n\ntutorial 페이지\nShiny 공식 tutorial 페이지를 살펴보고, 반응 출력을 이해하세요.\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson4/\n추가 예제 실행해 보기\n예제를 실행시켜 보고, 또다른 반응 출력을 경험해 보세요.\n\n\nshiny::runExample(\"03_reactivity\")\n\n\n\n\n\n\n",
      "last_modified": "2022-02-11T23:02:30+09:00"
    },
    {
      "path": "rmarkdown_resources.html",
      "title": "학습 리소스",
      "description": "**BitStat** 도움말 개발 참여를 위한 R 마크다운 관련 학습 리소스  \n",
      "author": [],
      "contents": "\n\nContents\nR 마크다운 학습과 관련 기술 학습을 위한 리소스\nR 마크다운 학습을 위한 리소스\nR 마크다운 관련 기술을 위한 리소스\ndistill 학습을 위한 리소스\n\n\nR 마크다운 학습과 관련 기술 학습을 위한 리소스\nR 마크다운 학습을 위한 리소스\nR 마크다운 홈페이지 :\nhttps://rmarkdown.rstudio.com/\n초급자/중급자 필수 사이트\n\nAwesome Rmarkdown :\nhttps://github.com/harryprince/awesome-rmarkdown\n유용한 R 마크다운 리소스 모음 사이트\n\nR 마크다운 관련 기술을 위한 리소스\nknitr 홈페이지 :\nhttps://yihui.org/knitr/\nElegant, flexible, and fast dynamic report generation with R\nknitr 개발자인 Yihui Xie가 만든 knitr 사이트\n\nPandoc 홈페이지 :\nhttps://pandoc.org/\n중급자 이상, Pandoc을 이해하기 위한 사이트\n\nLaTeX 홈페이지 :\nhttps://www.latex-project.org/\n중급자 이상, LaTeX을 이해하기 위한 사이트\n\nhtmltools 패키지 홈페이지 :\nhttps://rstudio.github.io/htmltools/\nshiny 앱에 html tags를 포함하는 기능\nR 마크다운 문서에 직접 커스트마이징된 HTML 태크를 삽입할 때 유용\n\ndistill 학습을 위한 리소스\ndistill 홈페이지 :\nhttps://rstudio.github.io/distill/\nDistill for R Markdown\ndistill의 전반적인 소개 사이트\n\ndistill Package docs :\nhttps://rstudio.github.io/distill/\ndistill 패키지다운 페이지\ndistill의 학습을 위한 Get started, 예제들\n\n\n\n\n",
      "last_modified": "2022-02-11T23:02:30+09:00"
    },
    {
      "path": "rmarkdown_yaml.html",
      "title": "YAML 이해하기",
      "description": "YMAL 헤더의 변경으로 문서의 형식과 모양이 바꾸는 것을 이해합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-11-09",
      "contents": "\n\nContents\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n튜토리얼의 범위\n\nYAML 헤더의 이해\nYAML 헤더는 무엇인가요?\nYAML 헤더 예제\n\n문서파일 형식 변경\n핸즈온 파일 준비하기\nMS 워드파일 생성하기\nPDF 파일 생성하기\n\n문서 서식 변경\n목차 넣기\n목차에 순번 넣기\n\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n들어가기\n문서 파일의 형식을 바꾸거나 전체 페이지의 테마를 바꾸고 싶다구요?!\n\nYAML로 문서 형식을 바꾸고 테마를 변경해 보세요. 그리고 덤으로 R 코드 실행을 위한 파라미터 값 설정으로 같은 포맷 다른 결과의 문서를 만들 수 있습니다.\n\n\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n앞서 만들었던 첫 R 마크다운 문서를 분해하면 다음과 같습니다.\nR 마크다운 문서의 분해YAML 헤더\nR 마크다운의 헤더 영역으로, 출력 문서를 세부적으로 제어합니다.\n\nR 코드 청크\n수행할 R 코드를 포함한 영역입니다.\n\n마크다운 태그를 포함한 텍스트\n문서의 서식과 텍스트를 정의하는 영역입니다.\n\n튜토리얼의 범위\n이 튜토리얼은 R 마크다운 문서의 분해 중에서의 YAML 헤더를 이해할 목적으로 진행합니다. 동일한 R 마크다운 문서로 어떻게 이질적인 형식의 파일과 모양을 빚어낼 수 있는지를 경험해 보세요.\nYAML 헤더의 이해\nYAML 헤더는 무엇인가요?\nYAML는 ’또 다른 마크업 언어(Yet Another Markup Language)’를 의미합니다. 복잡하고 어렵게 생각하지 마시고 생성할 문서 전체의 형식을 정의하는 헤더라고 이해하면 됩니다.\n헤더라는 의미는 R 마크다운 문서의 맨 앞에 위치한다는 것을 의미합니다. 그리고 YAML라는 것을 알려주기 위해서 청크는, “---”으로 시작해서 “---”로 끝납니다.\nYAML 헤더 예제\n이미 우리는 YAML 헤더를 경험했습니다.\n---\ntitle: \"첫 R 마크다운\"\nauthor: \"홍길동\"\ndate: \"10/31/2021\"\noutput: html_document\n---\nYAML 헤더에서 옵션 이름과 옵션 값은 콜론(:)으로 구분합니다. 한 줄에 한 쌍의 옵션 이름과 옵션 값이 올 수 있습니다.\ntitle: “첫 R 마크다운”은 문서 제목(타이틀)이 “첫 R 마크다운”임을 의미합니다. 그리고 output: html_document은 생성할 문서 파일이 HTML, 즉 웹 문서임을 rmarkdown 패키지에게 알려줍니다. 그러면 rmarkdown 패키지가 pandoc을 호출하서 웹 문서를 생성하게 됩니다.\n어떤 옵션은 서브 옵션을 포함하기도 합니다. 대표적인 것이 output 옵션입니다. 서브 옵션은 옵션 다음 줄에 기술해야 하며, 들어쓰기를 하여 자식 옵션임을 알려 주는 것이 헤더를 이해하는데 용이한, 암묵적인 룰입니다.\n다음과 같이 기술하는 것을 권장합니다.\noutput:\n  html_document:\n    toc: true\n문서파일 형식 변경\n핸즈온 파일 준비하기\n“첫 R 마크다운 문서 만들기” 핸즈온에서 생성한 “first_rmarkdown.Rmd” 파일을 이용하여 핸즈온을 진행하려 합니다.\n만약 파일이 없다면,\n핸즈온 튜토리얼을 수행하기 위해서 아래 “YAML 이해하기 튜토리얼 파일” 링크의 R 마크다운 파일을 다운로드합니다.\n링크에 마우스를 올려, 오른쪽 버튼으로 “다른이름으로 파일저장”을 실행합니다.\n\n다운로드한 파일을 RStudio로 읽어들입니다.\nYAML 이해하기 튜토리얼 파일\nMS 워드파일 생성하기\n1. MS 워드파일 생성하는 YAML 편집하기\n\nfirst_rmarkdown.Rmd은 HTML 문서를 생성합니다.\nYAML을 수정해서 MS 워드 파일을 생성하세요.\n’first_rmarkdown.Rmd’의 YAML을 변경 후 실행해 보세요.\n\n\n\n힌트 보기\nMS 워드파일을 생성하는 몇 가지의 방법이 있습니다.\n새 파일 만들기 아이콘 클릭 > New R Markdown 다이얼로그에서\n“Default Output Format:”의 Word 레디오 버튼 클릭하여 템플리트 생성/편집 후\nknit 아이콘을 클릭하여 워드파일 생성\n\nknit 아이콘을 마우스 오론쪽 클릭 후\n“Knit to Word”를 선택하여 워드파일 생성\n\nYAML 헤더를 수정하여 워드파일 생성\n“output:”의 값을 수정 \n\n3번 방법을 사용하세요.\n모범 답안\n---\ntitle: \"첫 R 마크다운\"\nauthor: \"홍길동\"\ndate: \"10/31/2021\"\noutput: word_document\n---\n\n\n생성한 워드파일은 다음과 같은 2페이지를 포함합니다.\n\n\n\n\nPDF 파일 생성하기\nR 마크다운으로 PDF 파일을 생성할 때, knitr은 LaTeX을 만드는 것은 이미 앞에서 다루었습니다. 그런데 PDF 파일을 생성할 때, 한가지 이슈가 발생합니다. 한글이 포함된 R 마크다운 문서의 경우는 다음과 같은 오류가 발생합니다.\n! Package inputenc Error: Unicode character 홍 (U+D64D)\n(inputenc)                not set up for use with LaTeX.\n\n이것은 LaTeX이 한글을 처리하지 못해서 발생하는 LaTeX 에러입니다.\n한글을 처리하기 위해서는 LaTeX 패키지인 kotex을 사용해야 합니다. 그리고 YAML 헤더에서, LaTeX이 kotex을 사용하도록 설정해 주어야 합니다.\n2. PDF 파일 생성하는 YAML 편집하기\n\nfirst_rmarkdown.Rmd은 HTML 문서를 생성합니다.\nYAML 헤더를 수정해서 PDF 파일을 생성하세요.\n’first_rmarkdown.Rmd’의 YAML을 변경 후 실행해 보세요.\n힌트를 참고해서 kotex을 사용하도록 설정하세요.\n\n\n\n힌트 보기\n“output:” 옵션으로 “pdf_document:”을 사용하세요.\n“pdf_document:” 옵션의 서브옵션 “includes:”에 LaTeX 헤더 파일을 설정하세요.\nLaTeX 헤더 파일은 “in_header:” 옵션으로 설정합니다.\n옵션 값에 “use_korean.tex” 파일을 기술하세요.\n\nYAML 헤더를 수정하여 워드파일 생성\n“output:”의 값을 수정 \n\n“use_korean.tex” 파일은 다음의 내용을 담고 있습니다. 직접 파일을 만들거나, 아래 경로에서 다운로드 받을 수 있습니다.\nuse_korean.tex 파일\n\\usepackage[hangul]{kotex}\n모범 답안\n---\ntitle: \"첫 R 마크다운\"\nauthor: \"홍길동\"\ndate: \"10/31/2021\"\noutput:\n  pdf_document:\n    includes:\n      in_header: use_korean.tex\n---\n\n\n생성한 PDF 파일은 다음과 같은 2페이지를 포함합니다.\n\n\n\n\n문서 서식 변경\n목차 넣기\n하나의 파일에 여러 페이지 분량의 컨텐츠를 담을 수 있는 MS 워드나 PDF는 문서의 앞 부분에 목차(toc, Table of Contents)를 넣을 수 있습니다. 목차는 전체 문서의 구성을 이해하는 데 용이할 뿐아니라 링크를 통해서 해당 빠르게 이동할 수 있는 장점이 있습니다.\n3. 문서에 목차를 포함하는 YAML 편집하기\n먼저 아래 경로에서 “second_rmarkdown.Rmd” 파일을 다운로드 받으십시요.\nsecond_rmarkdown.Rmd 파일\n\nsecond_rmarkdown.Rmd을 다운로드합니다.\n목차를 넣도록 옵션을 추가합니다.\ntoc 옵션을 사용합니다.\n\n목차는 4단계까지의 타이틀을 목차에 포함하십시요.\ntoc_depth 옵션을 사용합니다.\n\n목차에 넣을 타이틀 단계를 변경해가면서 타이틀의 모양을 비교해보십시요.\n\n\n힌트 보기\ntoc 옵션의 값은 논리값을 사용하는데, 대소문자를 구별하지 않습니다.\ntrue, True, TRUE, flase, False, FALSE로 표현이 가능합니다.\n\n본 튜토리얼의 모든 R 마크다운 문서는 가장 큰 타이들을 두번째 타이틀인 ##를 사용합니다.\n첫번째 타이틀인 #의 타이틀 제목이 필요 이상으로 커서 두번째 타이틀인 ##를 기준으로 사용합니다.\n그러므로 ##의 depth는 2입니다.\n\n모범 답안\n---\ntitle: \"두번째 R 마크다운\"\nauthor: \"홍길동\"\ndate: \"10/31/2021\"\noutput:\n  word_document:\n    toc: true\n    toc_depth: 4\n---\n\n\n생성한 워드 파일은 다음과 같이 목차를 포함합니다.\n\n\n\n\n목차에 순번 넣기\n목차에 순번을 넣을 수 있습니다.\n4. 문서에 순번이 있는 목차를 포함하는 YAML 편집하기\n\nsecond_rmarkdown.Rmd를 사용합니다.\n목차를 넣도록 옵션을 추가합니다.\ntoc 옵션을 사용합니다.\n\n목차는 3단계까지의 타이틀을 목차에 포함하십시요.\ntoc_depth 옵션을 사용합니다.\n\n타이틀과 목차에 순번을 넣으십시요.\nnumber_sections 옵션을 사용합니다.\n\n\n\n힌트 보기\nnumber_sections 옵션의 값은 논리값도 대소문자를 구별하지 않습니다.\n모범 답안\n---\ntitle: \"두번째 R 마크다운\"\nauthor: \"홍길동\"\ndate: \"10/31/2021\"\noutput:\n  word_document:\n    toc: true\n    toc_depth: 3\n    number_sections: true\n---\n\n\n생성한 워드 파일은 다음과 같이 목차를 포함합니다.\n\n\n\n\n요약\n핸즈온 요약\nR 마크다운 문서로 PDF 파일의 문서를 작성했습니다.\nR 마크다운 문서로 워드 파일의 문서를 작성했습니다.\nR 마크다운 문서에 목차를 삽입하고, 그 모양을 바꾸어 보았습니다.\nI can do it\nYAML 헤더를 사용하며, 생성하는 파일의 포맷을 바꾸고 목차 모양을 원하는대로 조정할 수 있습니다.\n\n\n\n",
      "last_modified": "2022-02-11T23:02:31+09:00"
    },
    {
      "path": "rmarkdown.html",
      "title": "R Markdown의 이해",
      "description": "재현가능한 연구의 개념과 Sweave, knitr, rmarkdown을 통해 R Markdown을 이해합니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2021-10-30",
      "contents": "\n\nContents\n재현가능한 연구\n마크업 언어\n마크다운\nLaTeX\nPandoc\n\nSweave\nSweave 매커니즘\nSweave 예제\n\nknitr 패키지\nR 마크다운 파일\nknitr 매커니즘\nknitr 예제\n\nrmarkdown 패키지\n\n재현가능한 연구\n‘재현가능한 연구’(Reproducible Research)라는 용어가 생소할 수 있으나 R 세계에서는 제법 회자되는 용어로, 공개한 연구의 결과물이 재현되고 검증될 수 있도록 하는 것을 의미합니다. 이 방법은 결국 연구가 발전하는 방향으로 재창조되는 결실을 가져옵니다. 이를 위해서는 데이터 분석의 방법을 실험 데이터에 연결하여 재현 검증될 수 있는 체계를 구축해야 합니다.\n재현가능한 연구를 이해하기 쉬운 사례로 설명하겠습니다. 데이터 입출력 및 분석 로직과 분석 결과를 표현하는 R 스크립트를 R 마크다운 문서에 정리합니다. R 마크다운 문서에는 연구에 대한 자세한 설명과 결과 해석이 포함되어 있고, 별도의 공간에 파일로 저장된 원시 데이터도 경로를 통해 문서와 연결되어 있습니다. 이 R 마크다운 문서와 데이터 파일을 RStudio 프로젝트나 R 패키지에 포함하여 배포하면 누구나 동일한 결과를 재현할 수 있게 됩니다.\n공개한 연구 자료에는 데이터, 분석을 위한 R 코드 및 과정의 설명과 결과의 해석 모두 포함되어야 합니다. 그러므로 재현가능한 연구는 공유의 가치를 인정하는 오픈소스 정신이 깃들여 있는 셈입니다.\nCRAN Task View: Reproducible Research에는 재현가능한 연구를 지원하는 여러 R 패키지를 소개하고 있습니다. 페이지에 방문하면 아마 많은 패키지와 다양한 기능의 소개에 놀랄 것입니다. 또한 방대한 기능에 무엇인 재현가능한 연구인지 이해하기 어려울 수 있습니다.\n이 글에서는 R 패키지가 지원하는 여러 기능 중에서 다음 두 가지 사례를 통해서 재현가능한 연구를 소개하겠습니다.\nLaTeX에 포함된 R 코드를 수행하여 PDF 문서를 만드는 사례와 관련 리소스\nR 마크다운 문서로 분석 결과가 포함된 HTML 보고서를 만드는 방법과 관련 리소스\n마크업 언어\n여러분은 웹 브라우저에 표현되는 컨텐츠(웹 페이지나 웹 어플리케이션)는 HTML로 구현된다는 것은 알고 계실겁니다. 그런데 HTML은 “Hyper Text Markup Langaue”의 약자라는 것은 아시나요? 그리고 영어의 정확한 의미를 아시나요?\n‘Text’(텍스트)는 의미의 전달을 목적으로, 알파벳, 한글, 숫자, 기호 등의 문자 세트로 문서나 글을 표현한 것입니다. 우리는 텍스트를 순차적으로 읽으면서 전달하는 의미를 이해하게 됩니다.\n‘Hyper Text’(하이퍼 텍스트)는 사전적으로 “텍스트를 뛰어넘는다”는 의미입니다. 웹 페이지는 본문에 다른 페이지로 이동하는 링크 기능을 이용해서 다른 페이지나, 페이지의 다른 영역으로 이동하는 링크 기능으로 페이지 내의 다른 문장의 영역으로 넘나들 수 있습니다. HTML에서는 이 링크를 하이퍼 링크(hyper link)라고 부릅니다. 즉, 하이퍼 링크를 통해서 텍스트를 비순차적으로 읽으면서, 순차적 전달보다 의미를 좀 더 쉽게 이해할 수 있습니다. 이것이 하이퍼 텍스트의 개념입니다.\n통상적으로 ‘텍스트 파일’은 서식이 없는 텍스트로 구성되어서, 어떤 에디터로도 쉽게 읽을 수 있는 파일을 의미합니다. 그러나 텍스트에 서식이 포함된 즉, 타이틀이나 주석, 볼드와 이탤릭처럼 폰트 페이스 등의 서식을 사용하거나 설명을 위해 이미지 삽화가 포함된 파일은 텍스트 에디터로는 읽을 수 없습니다. 별도의 프로그램으로만 열어볼 수 있습니다. HTML의 하이퍼 텍스트는 이러한 서식을 포함하고 있기 때문에 에디터가 아닌 웹 브라우저를 통해 읽어야 합니다.\n‘Markup Langaue’(마크업 언어)는 텍스트의 특정 위치에 표시를 하는 것을(마크업) 통해서 문서를 구조적으로 표현하는 컴퓨터 언어를 의미합니다. 물론 HTML에서의 구조적인 표현은 서식의 표현이나 페이지 간의 이동이나 페이지 내에서의 이동 등을 의미합니다.\n마크업 언어는 태그(tag) 등을 이용해서 문서나 데이터의 구조를 설명합니다. 즉 마크업이라는 작업에 태그를 이용하는 것입니다. 그래서 마크업 언어의 문법적 특징은 태그에 나타나게 됩니다.\n몇개의 HTML 태그를 예시하면, 하이퍼 링크 태그인 <a><\/a>는 하이퍼 링크를 정의하며, 이미지 태그인 <img />로 웹 페이지에 이미지를 삽입합니다.\n마크다운\n마크업 언어의 하나인 마크다운(Markdown)은 읽기 쉽고 쓰기 쉬운 양식을 작성하기 위해서 만들어졌습니다. 사용법이 매우 쉽기 때문에 빠르게 서식이 있는 문서를 만들 수 있습니다.\n\n\n\n\n\n\n\n“마크다운(Markdown)은 일반 텍스트 기반의 경량 마크업 언어입니다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, 일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징입니다. HTML과 리치 텍스트(RTF)1 등 서식 문서로 쉽게 변환되기 때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용됩니다.”2\n\n\nLaTeX\n저작을 위한 전문 시스템인 LaTeX(레이택)은 일반 R 사용자가 사용하기에는 다소 여렵지만 출력물의 퀄리티가 높아서 선호되기도 합니다.\n\n\n\n\n\n\n\nLaTeX(레이택)은 논문이나 출판물 등의 문서를 작성하는 데 쓰이는 전문 조판 시스템입니다. LaTeX은 수식과 다이어그램을 많이 사용하고, 도표와 이미지 삽입이 빈번한 이공계열에서 논문을 작성에 사용하고 있습니다. 또한 서적 등을 출판하는 출판업계에서도 사용하고 있습니다.\n\n\nPandoc\nRStudio를 설치하면 Pandoc(판독)도 함께 설치됩니다. 그 이유는 RStudio 기능에 재현가능한 연구를 위한 여러 문서 작성 기능이 있는데, Pandoc이 약방의 감초처럼 사용되기 때문입니다.\n\n\n\n\n\n\n\n“Pandoc은 마크업 형식을 다른 마크업 형식으로 변환해주는 라이브러리입니다. Pandoc은 Markdown, HTML, LaTeX 및 Word docx 등 수많은 마크업과 워드 프로세싱 형식 간에 변환을 수행합니다.”3\n\n\nSweave\nR 재단의 멤버십 회원인 오스트리아의 Friedrich Leisch가 2002년에 만든, utils 패키지의 Sweave(Leisch 2002) 함수는 자동으로 리포트는 생성해 주는 함수입니다.\nSweave는 S를 이용한 데이터 분석과 LaTeX 조판을 통합하여 데이터 분석 보고서를 작성합니다. S는 상용 S+와 오픈소스 R을 의미합니다. 아마 요즘에 개발되었다면 함수 이름을 Rweave로 작명했을 것입니다. 왜냐하면 2000년대 초반에는 R보다는 S+의 명성이 더 컸기 때문입니다.\nSweave라는 이름은 “S” 와 “Weave”를 결합한 복합어입이다. 그러므로 이 함수는 “에스 위브”라 읽어야 합니다. “Weave”는 날실(직물의 길이 방향, 즉 세로로 놓인 실)과 씨실(직물의 너비 방향, 즉 가로로 놓인 실)로 직물을 짜는 것을 의미하는 동사입니다. 즉 직물을 짜듯, S(S+와 R)의 코드를 LaTeX 조판 코드와 잘 결합하여 완성된 데이터 분석 보고서(직물)를 생성한다는 의미입니다.\n정리하자면, Sweave는 R 코드의 실행 결과(데이터 분석의 출력 정보, 표, 그래프 등)를 LaTeX 파일에 자동 삽입합니다. 그리고 이 LaTeX 파일로 PDF을 조판하여 최종 보고서를 생성하는 것입니다.\nSweave의 단점은 LaTeX과 결합하여 PDF 파일만 생성한다는 점입니다. 2000년대 초반에는 S 사용자의 많은 수가 LaTeX을 사용할 수 있는 통계학자였고, 학술지 등에 LaTeX으로 만들어진 논문을 투고해야 했기에 이 조합은 매우 유용하였습니다. 그러나 최근의 데이터 과학 필드에서는 HTML 기반으로 보고서를 작성하는 경우가 많기 때문에, HTML을 포함한 다양한 포맷의 보고서를 생성할 수 없다는 것은 단점일 수 밖에 없습니다.\nSweave 매커니즘\nS 코드 청크(Chunk, 덩어리)는 특정 작업을 수행하는 S 스크립트(이하 R 스크립트로 표현합니다)를 의미합니다. LaTeX으로 만들어진 날실 곧곧에 R 코드인 씨실을 넣기 위해서 코드 청크를 사용합니다.\nLaTeX 파일에 삽입하는 코드 청크는 다음의 포맷을 따릅니다.\n\n<<Sweave 옵션 영역>>=\nR 코드 삽입 영역\n@    \n\nSweave는 LaTeX 파일을 읽어 ‘<<>>=’ 과 ‘@’ 사이의 R 코드를 실행한 후, 실행 결과를 해당 위치의 LaTeX 파일에 삽입합니다. ‘<<’과’>>=’ 사이에 기술할 수 있는 Sweave 옵션은 다양한 출력을 제어할 수 있습니다. 예를 들면 플롯의 크기를 조정하거나 출력 텍스트의 서식을 제어할 수 있습니다. 경우에 따라서 실행 결과와 함께 R 코드도 출력할 수도 있습니다.\nR 코드의 실행 결과가 삽입된 LaTeX 파일은 LaTeX 시스템의 pdfLaTex이나 XeLaTeX 프로그램을 통해서 PDF 파일로 변환됩니다. Sweave 파일은 확장자로 “Rnw”를 사용해야 합니다. 그런데 이 확장자는 대소문자를 구별하지 않습니다만 관행적으로 첫 문자를 대문자로 표현합니다.\nRStudio는 이 몇 단계 과정을 한번에 엮어 실행합니다. 그래서 바로 PDF 파일을 만들어줍니다.\nSweave 예제\nSweave(Leisch 2002)에 삽입된 짧은 예제 파일을 살펴보겠습니다. example-1.Rnw 파일의 LaTeX 스크립트 중간에 R 코드가 삽입된 코드 청크 영역을 주의깊게 살펴보십시요.\n\n\\documentclass[a4paper]{article}\n\n\\begin{document}\nIn this example we embed parts of the examples from the\n\\texttt{kruskal.test} help page into a \\LaTeX{} document:\n\n<<>>=\ndata(airquality)\nkruskal.test(Ozone  ̃ Month, data = airquality)\n@\nwhich shows that the location parameter of the Ozone\ndistribution varies significantly from month to month.\nFinally we include a boxplot of the data:\n\n\\begin{center}\n<<fig=TRUE,echo=FALSE>>=\nboxplot(Ozone  ̃ Month, data = airquality)\n@\n\\end{center}\n\n\\end{document}\n\n\nSweave 파일은 Sweave에 의해서 다음과 같은 완전한, example-1.tex이라는 이름의 LaTex 파일로 변환됩니다. 시각화 결과는 example-1-002.pdf 파일로 따로 저장되게 됩니다.\n\n\\documentclass[a4paper]{article}\n\n\\usepackage{Sweave}\n\\begin{document}\n\nIn this example we embed parts of the examples from the\n\\texttt{kruskal.test} help page into a \\LaTeX{} document:\n\n\\begin{Sinput}\n> data(airquality)\n> kruskal.test(Ozone ~ Month, data = airquality)\n\\end{Sinput}\n\\begin{Soutput}\n      Kruskal-Wallis rank sum test\ndata: Ozone by Month\nKruskal-Wallis chi-squared = 29.2666, df = 4, p-value = 6.901e-06\n\\end{Soutput}\nwhich shows that the location parameter of the Ozone\ndistribution varies significantly from month to month.\nFinally we include a boxplot of the data:\n\n\\begin{center}\n\\includegraphics{example-1-002}\n\\end{center}\n\n\\end{document}\n\n\n마지막으로 LaTeX 파일을 pdfLaTex으로 변환하면 다음과 같은 PDF 문서가 만들어집니다.\nPDF 문서 내용knitr 패키지\n2010년대부터 R 필드의 패러다임 전환이 시작됩니다. 데이터 과학(data science)이 발전하면서 기존 통계학자들의 기여가 많았던 R 개발 진영에 데이터 과학자, 데이터 엔지니어, 프로그램 개발자들이 대거 활동하기 시작하면서 R 분석의 변화를 맞습니다.\n데이터 모델링 분야에서는 개별 함수들을 이용한 방법에서 Max Kuhn의 caret(2007) 패키지로, 데이터 시각화 분야에서는 R 그래픽 함수와 lattice 패키지에서 Hadley Wickham의 ggplot2(2007)로 진화합니다. 데이터 엔지니어링에서도 Hadley Wickham의 dplyr(2014)가 기존 데이터 프레임 연산을 대체합니다.\ncaret 패키지를 제외한 ggplot2, dplyr 패키지에 협업 가능한 유용한 패키지들이 에코 패키지로 결합하여 tidyverse 패키지군이 태동합니다. 이들은 RStudio라는 회사를 구심점으로 많은 유용한 패키지를 개발합니다. 특히 Hadley Wickham을 중심으로 많은 데이터 과학자와 데이터 엔지니어, 웹 개발자들이 두각을 나타냅니다.\n재현가능한 연구 분야도 발전하게 됩니다. Sweave의 단점을 보완하고 여러 유용한 기능을 추가한 knitr 패키지가 2012년 Yihui Xie에 의해 개발됩니다. 이제 데이터 분석 결과를 LaTeX 시스템 기반의 PDF로 조판하는 시대를 넘어서 HTML 기반의 WEB 채널로 배포되고 공유하는 시대가 도래한 것입니다.\n\n\n\n\n\n\n\n“Sweave에서 영감받은 knitr 패키지는 다른 애드온 패키지를 하나의 패키지로 결합4하여, R을 이용해서 동적으로 리포트를 생성하기 위해서 개발되었습니다.”5  이제 재현 가능을 연구를 위한 보고서 작성이 PDF를 넘어 HTML로 확장되고, 그 성능도 향상되기 시작합니다.\n\n\nknitr도 “knit”와 “R”을 결합한 복합어입이다. 그래서 “니트 알”로 발음해야 합니다. “knit”는 스웨터와 같은 옷을 뜨게질하는 것을 의미합니다. Sweave의 “Weave”가 직물을 직조하는 것과 동일한 의미입니다. 패키지 이름을 작명하는 것에도 위트가 숨어 있습니다. 마크다운 문서 곳곳에 다른 색상의 R이라는 털실로 뜨게질해서 무늬가 있는 스웨터(보고서)를 만드는 역할을 표현한 것입니다.\nR 마크다운 파일\n‘R 마크다운’(R Markdwon) 파일은 재현 개능한 연구를 위해서, 마크다운 문서에 R 코드 청크를 삽입한 파일입니다. 확장자로 “Rmd”를 사용하는데, 확장자는 Sweave 파일처럼 대소문자를 구별하지 않습니다.\nknitr 매커니즘\nknitr는 R 마크다운 파일의 R 코드 청크를 실행해서 그 결과를 마크다운 문서와 결합한 마크다운 파일을 생성합니다. 마크다운 파일의 확장자는 “md”입니다.\nknitr의 R 코드 청크는 다음의 포맷을 따릅니다.\n\n\n```{r, knitr 옵션 영역}\nR 코드 삽입 영역\n```    \n\n\nknitr는 R 마크다운 파일을 읽어 백틱(`) 문자 세개로 구성된 ‘```{r}’ 과 ‘```’ 사이의 R 코드를 실행한 후, 실행 결과를 해당 위치의 파일에 삽입하여 마크다운 문서를 생성합니다. 옵션은 다양한 출력을 제어할 수 있습니다. 예를 들면 플롯과 출력 텍스트의 서식을 제어할 수 있는 것은 물론 결과를 캐싱해서, 다음 작업에는 연산을 수행하지 않고 결과를 캐시에서 가져올 수도 있습니다.\nSweave가 Sweave 파일을 LaTeX 파일까지만 생성하고, pdfLaTeX 유틸리티가 LaTeX 파일을 PDF 파일로 변환하는 것처럼, knitr는 R 마크다운 파일을 마크다운 파일까지만 생성합니다. 그리고 pandoc이 마크다운 파일을 원하는 포맷의 문서 파일로 변환합니다. 두 방법의 차이점은 pdfLaTeX가 PDF 파일만 생성하는 것에 반해서, pandoc은 PDF를 포함해서 HTML, 워드, 파워포인트 파일까지 다양한 파일을 생성합니다.\nknitr는 Sweave 파일도 처리할 수 있습니다. 이 경우는 knitr 패키지의 Sweave2knitr 함수가 Sweave 파일을 R 마크다운로 변환한 다음에 작업합니다. 그러나 호환성이 다소 떨어지고, kintr의 다양한 기능으로 Sweave이 아니라 knitr을 사용하는 것을 권장합니다.\nknitr 예제\nSweave(Leisch 2002)에 삽입된 예제를 example-1.Rmd이라는 이름의 다음과 같은 R 마크다운 파일로 생성하였습니다.\n\n\nIn this example we embed parts of the examples from the\n*kruskal.test* help page into a LaTeX document:\n\n```{r}\ndata(airquality)\nkruskal.test(Ozone ~ Month, data = airquality)\n```\nwhich shows that the location parameter of the Ozone\ndistribution varies significantly from month to month.\nFinally we include a boxplot of the data:\n\n```{r, echo=FALSE}\nboxplot(Ozone ~ Month, data = airquality)\n```  \n\n\n\n그리고 knitr 패키지의 knit 함수를 이용해서 마크다운 파일로 변경합니다.\n\n\nlibrary(knitr)\n\nknit(\"example-1.Rmd\")\n\n\n\n생성된 마크다운 파일인 example-1.md는 다음과 같습니다.\n생성된 마크다운 파일knitr 패키지의 pandoc 함수는 Pandoc을 랩핑한 함수입니다. 다음 명령을 마크다운 문서를 HTML로 변환하는 R 스크립트입니다. 메시지를 보면 Pandoc이 호출되어 HTML을 생성함을 유추할 수 있습니다.\n\npandoc(\"example-1.md\", format = \"html\")\nExecuting: pandoc -t html -o 'example-1.html' 'example-1.md'\n[1] \"example-1.html\"\n\n생성된 HTML 파일인 example-1.html이 웹 브라우저에 표현된 내용은 다음과 같습니다.\n생성된 HTML 파일의 랜더링 화면\nRStudio를 사용하면 이런 몇 단계의 작업을 메뉴 하나로 함축해 놓았기 때문에, 그냥 메뉴 아이콘을 눌러 작업할 수 있습니다. 그래서 단계적으로 함수를 호출하는 것을 모르는 R 사용자가 대부분입니다. 지극히 정상입니다. 다만 RStudio를 사용하지 않는 R 사용자는 단계적으로도 작업을 할 수 있도록, 함수를 호출하는 방법을 숙지해야 합니다.\n\nrmarkdown 패키지\nSweave와 knitr는 문서에 삽입된 R 코드 청크를 실행하고 그 결과를 LaTeX이나 마크다운 문서에 삽입하는 작업을 수행합니다. 그러나 이 작업은 최종 문서를 만드는 작업의 일부입니다. R 마크다운 파일이 문서가 되기 위해서는 다음의 워크플로우를 거쳐야 합니다. 이 작업을 수행해 주는 것이 rmarkdown 패키지입니다.\n\n\n\n\n\n\n\n\n\n\nrmarkdown는 마크다운과 R 코드를 연동하여 재현 가능한 문서를 작성할 수 있는 R 패키지입니다. 마크다운의 마크업 태그는 파일에 저장된 코드를 실행한 결과와 매시업되어 사용자가 의도한 저작 콘텐츠를 고품질의 문서로 자동으로 생성해 줍니다.  R Markdown 문서는 재현 가능하며 수십 가지의 정적 및 동적 출력 형식을 지원합니다.\n\n\nR 마크다운은 보고서만 만드는 도구가 아닙니다. R 마크다운을 이용하면 다음 그림6처럼 블로그와 같은 웹 페이지를 만들 수도 있으며, 서적도 출판할 수 있습니다.\nDocument your analyses, make a website, make slides… the world is your oyster!R 마크다운을 소개하는 이 웹 페이지도 rmarkdown 기반으로 만들었습니다. (정확히 말하자면 distill 패키지를 이용한 R 마크다운 파일의 웹 페이지 생성)\n많은 문서들이 웹 페이지로 생산되고, 배포 공유되는 세상입니다. R 마크다운을 이용해서 재현 가능한 문서를 생산하는 것을 적극 추천합니다. 특히 RStudio는 R 마크다운을 생산하고 배포하는 기능을 쉽게 메뉴화했습니다. 어렵게 느끼지 말고, R 기반의 데이터 분석 경험을 적극 자산화하고 공유하시기 바랍니다.\n\n\n\nLeisch, Friedrich. 2002. “Sweave: Dynamic Generation of Statistical Reports Using Literate Data Analysis.” In Compstat 2002 - Proceedings in Computational Statistics, edited by Wolfgang Härdle and Bernd Rönz, 575–80. Physica Verlag, Heidelberg. http://www.stat.uni-muenchen.de/ leisch/Sweave.\n\n\nhttps://ko.wikipedia.org/wiki/서식_있는_텍스트_포맷. 서식 있는 텍스트 포맷 또는 리치 텍스트 포맷(Rich Text Format, 줄여서 RTF)은 마이크로소프트사가 1987년에 개발한 규격인 사유의 문서 파일 형식이며 크로스 플랫폼 문서 교환을 위하여 만들어졌다.↩︎\nhttps://ko.wikipedia.org/wiki/마크다운 발췌↩︎\nhttps://pandoc.org/MANUAL.html 발췌↩︎\nknitr ≈ Sweave + cacheSweave + pgfSweave + weaver + animation::saveLatex() + R2HTML::RweaveHTML() + highlight::HighlightWeaveLatex() + 0.2 * brew + 0.1 * SweaveListingUtils + more↩︎\nknitr 홈페이지 https://yihui.org/knitr/ 발췌↩︎\nhttps://www.williamrchase.com/slides/ggplot_intro.html#57↩︎\n",
      "last_modified": "2022-02-11T23:02:32+09:00"
    },
    {
      "path": "RStudio.html",
      "title": "첫 R 마크다운 문서 만들기",
      "description": "RStudio에서 R 마크다운 문서를 활용하는 방법을 익힙니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-10-31",
      "contents": "\n\nContents\nR 마크다운 문서 만들기\nR 마크다운 문서 만들기\nR 마크다운 문서 저장하기\n\nHTML 생성하기\n보고서 파일 생성하기\n보고서 파일 살펴보기\n\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n들어가기\nRStudio를 제대로 사용하는 것은 R 마크다운을 사용할 줄 안다는 것입니다.\n\nRStudio는 재현가능한 연구를 위한 최적의 솔루션이기 때문입니다. 이제 여러분은 RStudio를 제대로 사용할 수 있게 됩니다.\n\n운영체제에 따라 화면 모습에 다소 차이가 있을 수 있습니다. 염두에 두시기 바랍니다.\n\n\nR 마크다운 문서 만들기\nR 마크다운 문서를 생성하는 방법을 학습합니다. 지시에 따라 R 마크다운 파일을 생성합니다.\nR 마크다운 문서 만들기\nRStudio에서 R 마크다운 문서를 만들어 보겠습니다. RStudio의 좌측 상단의 새로운 파일 생성 아이콘을 누른 후, 메뉴에서 “R Markdown…”을 선택합니다.\n새 파일 만들기 아이콘New R Markdown 다이얼로그에서 다음을 입력하고 ‘OK’ 버튼을 누르세요.\n제목에 ’첫 R 마크다운’을 입력합니다.\n저자에 당신의 이름을 입력합니다. 예시에는 ’홍길동’을 입력했습니다.\n출력 포맷에서 HTML을 선택합니다. 기본값입니다.\n‘OK’ 버튼을 눌러, R 마크다운 문서를 생성하세요.\nNew R Markdown 다이얼로그다이얼로그의 왼쪽 헤더에는 R 마크다운의 종류를 선택할 수 있는 메뉴가 있습니다. 메뉴를 선택하면, 오른쪽에 해당 메뉴에 따라 R 마크다운 파일을 생성하는 옵션들이 나타납니다.\nDocument\n정적 문서(static documents)를 생성하기 위한 메뉴입니다.\nHTML, PDF, 워드 파일을 생성할 수 있습니다.\n\nPresentation\n발표 슬라이드를 생성하기 위한 메뉴입니다.\nHTML, PDF, 파워포인트 파일의 슬라이드를 생성할 수 있습니다.\n\nShiny\nShiny 기반의 동적 문서(dynamic documents)를 생성하기 위한 메뉴입니다.\nShiny 웹앱이나 Shiny 슬라이드를 생성합니다.\n\nForm Template\n특정 목적을 위해서 미리 준비한 R 마크다운 문서 템플리트를 사용하는 메뉴입이다.\n관련 템플리트를 지원하는 R 패키지가 설치되어야 합니다.\n\n\n\n\n\n솔루션\n\nNew R Markdown 다이얼로그를 여는 방법은 두가지입니다. 튜토리얼에서 제시하는 메뉴 아이콘 선택 방법과 \"File > New File > Markdown File\" 메뉴를 이용하는 방법입니다. 메뉴 아이콘 이용 방법이 간결하고 쉽습니다.\n\n\n메뉴를 이용하는 방법생성된 R 마크다운 템플리트 문서를 살펴보세요.\n제목과 당신의 이름은 어느 위치에 표현되어 있습니까?\n’output:’은 어떻게 기술되어 있습니까?\n어떤 내용의 문서를 생성할 것이지를 이야기해 보세요.\n두 개의 R 코드 청크를 해석해 보세요.\n‘pressure’ 청크는 어떤 플롯을 그리는 것일까요?\n\nR 마크다운 문서의 이름이 ’Untitled1’인 것을 확인하세요.\n아직은 파일로 저장되지 않은 상태입니다.\n\n생성된 R 마크다운 템플리트 문서R 마크다운 문서 저장하기\n생성된 R 마크다운 파일의 이름이 정해지지 않았음을 발견했습니다.\n좌측 상단의 디스켓 모양의 아이콘을 눌러 파일을 저장하세요.\n파일 이름에 ’first_rmarkdown’을 입력하세요.\n‘Save’ 버튼을 눌러 파일을 저장하세요.\n\n생성된 R 마크다운 템플리트 문서HTML 생성하기\nRStduio는 knitr을 이용해서 R 마크다운 문서를 마크다운 문서로 변환합니다. 그래서 메뉴에 ‘knit’라고 표현하는 것은 지정한 포맷의 보고서 파일을 생성하라는 의미입니다.\n마크다운 문서로 최종 보고서 파일을 생성하는 방법을 학습합니다. 지시에 따라 보고서 파일을 생성합니다.\n보고서 파일 생성하기\n좌측 상단의 뜨개실 이미지 아이콘을 눌러 보고서 파일을 생성하세요.\n뜨개실 이미지 아이콘 옆에 ’Knit’라는 문자열과 역삼각형 이미지를 확인하세요.\n’Knit’라는 문자열과 역삼각형 이미지를 클릭하세요.\n주의) 역삼각형 이미지가 아닌 ‘Knit’ 문자열을 클릭하면 메뉴의 팝업없이 바로 실행됩니다.\n\n팝업된 메뉴에서 ’Knit to HTML’을 눌러 보고서 파일을 생성합니다.\nknit 메뉴 아이콘팝업 메뉴에는 최종 파일의 포맷을 선택하는 기능, 파라미터를 추가하는 메뉴 등이 포함되어 있습니다.\nKnit to HTML\nHTML 문서를 생성합니다.\n\nKnit to PDF\nPDF 문서를 생성합니다.\n\nKnit to Word\n워드 문서를 생성합니다.\n\nKnit with Parameters…\nR 마크다운 문서에 입력 파라미터를 설정했을 경우, 파라미터의 값을 정의합니다.\n\nKnit Directory\n생성한 최종 보고서를 저장할 경로를 설정합니다.\nDocument Directory\nR 마크다운 파일이 있는 디렉토리에 저장합니다.\n기본값입니다.\n\nProject Directory\nR 프로젝트 안에서의 R 마크다운 파일일 경우, 프로젝트 루트에 저장합니다.\n\nCurrent Working Directory\n현재 R 작업 경로에 저장합니다.\n\n\n보고서 파일 살펴보기\n브라우저에 출력된 HTML 문서를 확인하세요.\n제목과 저장 이름이 출력된 위치와 크기를 확인하세요.\nR 코드 청그 위치에 어떤 내용이 표시되어 있습니까?\nHTML 본문의 https://rmarkdown.rstudio.com을 눌러보세요.\n\n브라우저에 출력된 HTML 문서요약\n핸즈온 요약\nR 마크다운 문서를 생성했습니다.\nR 마크다운 문서로 HTML 문서를 생성했습니다.\nI can do it\nRStudio의 메뉴를 이용해서 R 마크다운 문서를 작성하고, R 마크다운 문서의 R 코드 청크를 실행하여 HTML 문서를 생성할 수 있습니다.\n\n\n\n",
      "last_modified": "2022-02-11T23:02:32+09:00"
    },
    {
      "path": "run_batch.html",
      "title": "배치 처리하기",
      "description": "R 스크립트를 배치 작업으로 수행해 봅니다. 이 방법은 정기적으로 데이터를 수집할 때 유용한 기법입니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-11",
      "contents": "\n\nContents\n배치 처리의 이해\n배치 처리의 정의\n배치 처리의 활용\n\n배치 프로그램 작성\n대상 지역 데이터 생성\n배치 프로그램 생성\n\n배치 프로그램 실행\nRStudio 이용한 실행\nShell Script를 이용한 실행\n\n배치작업 스케줄링하기\n스케줄 조회하기\n스케줄 정의하기\ncrontab 스케줄 정의 방법\n\ncron 스케줄 Trouble Shooting\nMac에서의 Trouble Shooting\n작업경로 Trouble Shooting\n한글환경 Trouble Shooting\ntidyverse 한글환경 Trouble Shooting\n\n\n\n\n\n\n\n들어가기\n주기적으로 자주 실행되는 코드가 있습니다.\n한번이 아니라 여러번 실행될 작업\n입니다.\n\n귀찮을 수 있는 성가신 작업을, 안전하고 쉽게 수행할 방법은 없을까요? 여기 그 해답을 알려 줍니다.\n\n\n배치 처리의 이해\n배치 처리의 정의\n다음은 위키백과에 실린 배치 처리의 정의입니다.\n“일괄 처리(batch processing)란 최종 사용자의 개입 없이 또는 (자원이 허가한다면) 실행을 스케줄링할 수 있는 작업(job)의 실행을 의미합니다.1 컴퓨터 프로그램 흐름에 따라 순차적으로 자료를 처리하는 방식입니다.”\n여기서 중요한 의미는 다음과 같습니다.\n프로그램 흐름에 따라 순차적으로 자료를 처리\n사용자의 개입 없이 스케줄링할 수 있는 작업\n배치 처리의 활용\n아파트 실거래 상세 정보를 수집하기 위해서는 여러 번 API를 호출해야 합니다. 이 API는 2006년 1월부터의 데이터를 제공합니다. 그러므로 2006년 1월 이후의 모든 데이터를 수집하기 위해서는 여러 번이 아니라, 여러 날의 작업이 필요합니다. 왜냐하면 API 호출이 하루에 1,000회로 제한되어 있기 때문입니다.\n여기서는 국토교통부의 아파트매매 실거래 상세 자료를 배치 작업으로 수집하는 방법을 소개합니다.\n배치 프로그램 작성\n대상 지역 데이터 생성\nSQLite DBMS에 실거래 상세 자료를 수집할 대상 지역 정보를 저장합니다. koscrap 패키지의 행정구역 코드 정보 데이터인 legal_divisions을 이용합니다.\n\n\n################################################################################\n## 01.  Create meta datas\n################################################################################\nJOB_LAWD_INFO <- koscrap::legal_divisions %>% \n  filter(MAINTAIN %in% \"Y\") %>% \n  select(MEGA_CD, MEGA_NM, CTY_CD, CTY_NM) %>% \n  unique() %>% \n  mutate(DEAL_YM = NA)\n  \n################################################################################\n## 02.  Export to DBMS\n################################################################################\ndb_name <- here::here(\"collect_data\", \"data\", \"TRADE.sqlite\")\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), db_name)\nDBI::dbWriteTable(con, \"TB_JOB_LAWD_INFO\", JOB_LAWD_INFO, overwrite = TRUE)\nDBI::dbDisconnect(con)\n\n\n\n배치 프로그램 생성\n02_import_trade_apt.R 파일에 실거래 상세 자료를 수집하는 메인 프로그램을 다음과 같이 만듭니다.\n\n\n################################################################################\n## 01. Prepare\n################################################################################\n\ncat(glue::glue(\"Start Job - {lubridate::now()}\\n\\n\"))\n\n##==============================================================================\n## 01.01. Load library\n##==============================================================================\nlibrary(\"dbplyr\")\nlibrary(\"dplyr\")\n\n##==============================================================================\n## 01.02. Set parameters\n##==============================================================================\nauth_key <- \"qhsUf6N2sxleUCslMfvPymlechknww5sKxAKf2Wrabp2e6gHNcXZ3tl%2FTfBahx%2FOcV5FTlquUu9RDijxdGaF2g%3D%3D\"\n\nDEAL_YMD <- \"20060101\" %>% \n  as.Date(format = \"%Y%m%d\") %>% \n  seq(to = as.Date(\"20211201\", format = \"%Y%m%d\"),  by = \"month\") %>% \n  format(\"%Y%m\")\n\n##==============================================================================\n## 01.03. Connect DBMS \n##==============================================================================\ndb_name <- here::here(\"collect_data\", \"data\", \"TRADE.sqlite\")\ncon <- DBI::dbConnect(RSQLite::SQLite(), db_name)\n\n################################################################################\n## 02. Scrap data from REST API server\n################################################################################\n##==============================================================================\n## 02.01. 대상 지역코드 선정\n##==============================================================================\nLAWD_CD <- con %>% \n  tbl(\"TB_JOB_LAWD_INFO\") %>% \n  filter(is.na(DEAL_YM)) %>% \n  filter(row_number() <= 4) %>% \n  select(CTY_CD) %>% \n  pull()\n\n##==============================================================================\n## 02.02. 작업 대상 파라미터 선정\n##==============================================================================\nconditions <- tidyr::expand_grid(DEAL_YMD, LAWD_CD)\n\n##==============================================================================\n## 02.03. Scrap from 국토교통부_아파트매매 실거래 상세 자료 REST server\n##==============================================================================\ntrade_list <- NROW(conditions) %>%\n  seq() %>% \n  purrr::map_df({\n    function(x) {\n      koscrap::trade_apt(auth_key, \n                LAWD_CD = conditions$LAWD_CD[x], \n                DEAL_YMD = conditions$DEAL_YMD[x],\n                chunk = 1000,\n                do_done = TRUE\n      )\n    }\n  }) %>% \n  mutate(CREATE_DT = as.POSIXlt(date(), format = \"%a %b %d %H:%M:%S %Y\")) %>% \n  mutate(CREATE_DT = as.character(CREATE_DT))\n\ncat(glue::glue(\"{NROW(trade_list)} cases of data were collected.\\n\\n\"))\n\n##==============================================================================\n## 02.04. 작업 정보 업데이트\n##==============================================================================\nTB_JOB_LAWD_INFO <- con %>% \n  tbl(\"TB_JOB_LAWD_INFO\") %>% \n  left_join(\n    trade_list %>% \n      mutate(DEAL_DATE = substr(DEAL_DATE, 1, 7)) %>%\n      mutate(DEAL_DATE = stringr::str_remove(DEAL_DATE, \"-\")) %>%\n      group_by(LAWD_CD) %>% \n      summarise(DEAL_DATE = max(DEAL_DATE)),\n    by = c(\"CTY_CD\" = \"LAWD_CD\"),\n    copy = TRUE\n  ) %>% \n  mutate(DEAL_YM = ifelse(is.na(DEAL_YM), DEAL_DATE, DEAL_YM)) %>% \n  select(-DEAL_DATE) %>% \n  collect()\n\n##==============================================================================\n## 02.05. 작업 정보와 수집 데이터 DB 저장\n##==============================================================================\nDBI::dbWriteTable(con, \"TB_TRADE_APT\", trade_list, append = TRUE)\nDBI::dbWriteTable(con, \"TB_JOB_LAWD_INFO\", TB_JOB_LAWD_INFO, overwrite = TRUE)\nDBI::dbDisconnect(con)\n\ncat(glue::glue(\"Finsh Job - {lubridate::now()}\\n\\n\"))\n\n\n\n배치 프로그램 실행\nRStudio 이용한 실행\nRStudio의 “Tools > Jobs > Start Local Job…” 메뉴를 선택합니다.\nJobs 실행 메뉴다음과 같은 메뉴 다이얼로그에서 “R Script”와 “Working Directory”를 선택한 다음, “Start” 버튼을 누르면 해당 스크립트인 02_import_trade_apt.R 파일이 실행됩니다.\n실행 대상의 선택프로그램이 실행되는 과정에서는 우측 상단처럼 프로그레스 바에서 작업의 진행상태를 확인할 수 있습니다.\nJobs 실행 상태프로그램의 실행이 종료되면 다음처럼 프로그레스 바 위치에 작업이 끝났음을 알려주는 정보가 표시됩니다.\nJobs 실행 종류Shell Script를 이용한 실행\nLinux나 Mac의 콘솔에서도 배치 작업을 실행할 수 있습니다.\n먼저 다음과 같은 “excute_trade_apt.sh”이라는 파일의 Shell Script를 작성합니다. 이 스크립트는 R 스크립트가 아닌 쉘 스크립트입니다.\n이 스크립트를 실행하기 앞서서 로그를 쌓을 디렉토리를 만들어야 합니다. “./collect_data”가 작업 경로로 가정한다면, “./collect_data/log” 디렉토리를 미리 생성해 놓습니다.\n\n#!/bin/sh\n\n# 오늘 날짜\nYMD=`date \"+%Y-%m-%d\"`\n# 포르젝트 ㄹ디렉토리\nproject_dir='/Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data'\n# 작업 디렉토리\nwork_dir=`expr $project_dir/collect_data`\n\n# 로그 파일경로 및 이름\nlog_file=`expr $work_dir/log/trade_apt_$YMD.log`\n\n/usr/local/bin/Rscript $work_dir/R/02_import_trade_apt.R > $log_file\n\n그리고 콘솔에서 해당 파일에 실행 권한을 부여합니다.\n\nchmod +x excute_trade_apt.sh\n\n콘솔에서 스크립트를 실행해 봅니다. 다음은 필자의 Mac 콘솔에서 실행한 결과입니다. 패키지가 로딩될 때, 메시지가 콘솔에 출력되었습다.\n\n(base) choonghyunryu@myWorld R % ./excute_trade_apt.sh \n\n다음의 패키지를 부착합니다: ‘dplyr’\n\nThe following objects are masked from ‘package:dbplyr’:\n\n    ident, sql\n\nThe following objects are masked from ‘package:stats’:\n\n    filter, lag\n\nThe following objects are masked from ‘package:base’:\n\n    intersect, setdiff, setequal, union\n\n이 메시지는 작업에 영향을 주지 않습니다만, 보기 싫다면 다음처럼 배치파일을 수정해서 메시지의 출력을 없애줄 수도 있습니다. library() 함수에 warn.conflicts 인수를 사용해서 메시지 출력을 제거합니다.\n\n\nlibrary(\"dbplyr\", warn.conflicts = FALSE)\nlibrary(\"dplyr\", warn.conflicts = FALSE)\n\n\n\n작업 실행 중에 생성된 로그를 확인해 봅니다.\n\n(base) choonghyunryu@myWorld R % cat ../log/trade_apt_2022-02-09.log\nStart Job - 2022-02-09 07:42:52\n253602 cases of data were collected.\nFinsh Job - 2022-02-09 08:05:38\n\n배치작업 스케줄링하기\n배치작업의 스케줄링에서 가장 일반적인 것은 Unix-like 시스템의 cron일 것입이다. 여기서는 cron에 대해서 알아보려 합니다.\n스케줄 조회하기\ncron 스케줄링은 cron table에 정의합니다. cron table에 정의된 스케줄 목록은 Unix-like 시스템의 터미널에서 crontab -l 명령어로 조회합니다. 필자는 MacOS에서 수행합니다. MacOS의 터미널도 Unix-like 시스템의 일종이므로 cron을 사용할 수 있습니다.\n아직 정의된 cron 스케줄링이 없기 때문에 스케줄이 없다는 메시지가 출력되었습니다.\n\n(base) choonghyunryu@myWorld R % crontab -l\ncrontab: no crontab for choonghyunryu\n\n스케줄 정의하기\n이제 스케줄을 정의해 보겠습니다. crontab -e 명령어로 스케줄을 수정할 수 있습니다. 아직 정의된 스케줄이 없기 때문에 아무 내용도 없는 에디터(vi 에디터) 화면이 나타납니다. 에디터에 스케줄을 정의한 후 저장합니다.\n\n(base) choonghyunryu@myWorld R % crontab -e\n\n이번에는 cron table에 정의된 스케줄 목록이 출력됩니다. 방금 정의했던 스케줄입니다. 앞서 만들었던 아파트 실거래 상세정보의 쉘 스크립트를 수행하는 스케줄입니다. 매일 새벽 1:00에 excute_trade_apt.sh을 수행하라는 정의입니다.\n\n(base) choonghyunryu@myWorld R % crontab -l\n0 1 * * * /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_data/R/excute_trade_apt.sh\n\ncrontab 스케줄 정의 방법\ncrontab의 작업 스케줄은 화이트스페이스로 분리된 6개의 컬럼으로 정의하합니다. 6개의 컬럼에 대한 의미는 다음과 같습니다.\n\n분  시간  일  월  요일 명령어\n\n분부터 요일까지의 5개 컬럼은 숫자로 정의하며 다음과 같은 범위에서 정의할 수 있습니다.\n분: 0 ~ 59\n시간: 0 ~ 23\n일: 1 ~ 31\n월: 1 ~ 12\n요일: 0 ~ 7\n0과 7은 일요일, 1부터 월요일이며 6은 토요일\n\n아스터리스크(*)는 해당하는 모든 주기를 의미합니다. 분 위치의 아스터리스크(*)는 매분을 의미합니다.\n그러므로 다음 정의는 매월 첫째날, 8시부터 9시 전까지 매분동안 /home/usr1/run.sh을 실행합니다.\n\n*  8  1  *  * /home/usr1/run.sh\n\n다음 정의는 매일 매시간 0분과 30분에, 즉 30분 주기로 /home/usr1/run.sh을 실행합니다.\n\n0,30  *  *  *  * /home/usr1/run.sh\n\n다음 정의는 자정과 정오에 0분부터 30분까지 매분 /home/usr1/run.sh을 실행합니다.\n\n0-30  0,12  *  *  * /home/usr1/run.sh\n\ncron 스케줄 Trouble Shooting\ncron 스케줄의 수행환경은 별도의 가상환경을 만들어 수행하는 것과 흡사합니다. 그래서 익숙하지 않으면 여러 에러가 발생할 수 있습니다. 여기서는 이런 예기치 못한 에러를 해결하는 방법을 다룹니다.\nMac에서의 Trouble Shooting\n기대했던 cron 스케줄이 정상적으로 실행된 것 같지 않습니다. 혹시나 해서 mail 박스를 열어봅니다. 터미널에서 mail 명령어로 가능합니다.\n일반적으로 cron 스케줄 작업에 대한 로그는 메일로 받을 수 있습니다. 다음과 같은 메일이 와 있었습니다.\n\n(base) choonghyunryu@myWorld R % mail\nMail version 8.1 6/6/93.  Type ? for help.\n\"/var/mail/choonghyunryu\": 1 message 1 new\n>N  1 choonghyunryu@myWorl  Thu Feb 10 07:35  18/903   \"Cron <choonghyunryu@myWorld> /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_da\"\n? p\nMessage 1:\nFrom choonghyunryu@myWorld.local  Thu Feb 10 07:35:01 2022\nX-Original-To: choonghyunryu\nDelivered-To: choonghyunryu@myWorld.local\nFrom: choonghyunryu@myWorld.local (Cron Daemon)\nTo: choonghyunryu@myWorld.local\nSubject: Cron <choonghyunryu@myWorld> /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_data/R/excute_trade_apt.sh\nX-Cron-Env: <SHELL=/bin/sh>\nX-Cron-Env: <PATH=/usr/bin:/bin>\nX-Cron-Env: <LOGNAME=choonghyunryu>\nX-Cron-Env: <USER=choonghyunryu>\nDate: Thu, 10 Feb 2022 07:35:00 +0900 (KST)\n\n/bin/bash: /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_data/R/excute_trade_apt.sh: Operation not permitted\n\n? \n\nOperation not permitted 메시지에 주목해야 합니다. 구글링해보니, MacOS의 보안시스템에 관련된 이슈였습니다. 원인은 cron 프로세스가 MacOS 파일시스템의 전체 디렉토리의 접근 권한이 없기 때문입니다.\n다음과 같은 과정으로 문제를 해결합니다.\n먼저 시스템 환경설정에서 보안 및 개인 정보 보호 메뉴를 선택합니다.\n보안 및 개인 정보 보호 메뉴실행보안 및 개인 정보 보호 메뉴에서 전체 디스크 접근 권한을 선택한 후, 자물쇠를 해제하고 “+” 버튼을 누릅니다.\n전체 디스크 접근 권한 설정화면“⌘” + “⇧” + “G” 버튼을 동시에 누른 후, 나타난 메뉴에 /usr/sbin을 입력 후 이동 버튼을 누릅니다.\n/usr/sbin 폴더 이동/usr/sbin 경로의 파일에서 cron을 선택합니다.\ncron 파일 선택이제 전체 디스크 접근 권한에서 cron이 선택된 것을 확인할 수 있습니다.\ncron 파일 선택작업경로 Trouble Shooting\ncron에 등록할 프로그램에서 파일의 경로는 상대경로가 아닌, 절대경로를 사용해야 합니다.\nexcute_trade_apt.sh에서는 here 패키지를 이용해서 SQLite DBMS의 경로를 상대경로로 지정했습니다. 그래서 cron에서 다음과 같은 에러가 발생했습니다. 상대경로로 정의했던 DBMS 위치라서, DBMS에 접속하지 못했습니다.\n\n(base) choonghyunryu@myWorld R % mail\nMail version 8.1 6/6/93.  Type ? for help.\n\"/var/mail/choonghyunryu\": 1 message 1 new\n>N  1 choonghyunryu@myWorl  Thu Feb 10 08:02  20/834   \"Cron <choonghyunryu@myWorld> /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_da\"\n? p\nMessage 1:\nFrom choonghyunryu@myWorld.local  Thu Feb 10 08:02:03 2022\nX-Original-To: choonghyunryu\nDelivered-To: choonghyunryu@myWorld.local\nFrom: choonghyunryu@myWorld.local (Cron Daemon)\nTo: choonghyunryu@myWorld.local\nSubject: Cron <choonghyunryu@myWorld> /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_data/R/excute_trade_apt.sh\nX-Cron-Env: <SHELL=/bin/sh>\nX-Cron-Env: <PATH=/usr/bin:/bin>\nX-Cron-Env: <LOGNAME=choonghyunryu>\nX-Cron-Env: <USER=choonghyunryu>\nDate: Thu, 10 Feb 2022 08:02:02 +0900 (KST)\n\nError: Could not connect to database:\nunable to open database file\nExecution halted\n\n? \n\n그래서 DBMS에 접속하는 로직을 다음과 같이 수정했습니다. 주석으로 처리한 부분이 기존의 상대경로 정의입니다. 이 부분을 절대경로 위치로 바꿨습니다.\n\n\n##==============================================================================\n## 01.03. Connect DBMS\n##==============================================================================\n#db_name <- here::here(\"collect_data\", \"data\", \"TRADE.sqlite\")\ndb_name <- \"/Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_data/data/TRADE.sqlite\"\ncon <- DBI::dbConnect(RSQLite::SQLite(), db_name)\n\n\n\n한글환경 Trouble Shooting\n절대경로로 변경하여, 해당 이슈는 해결되었습니다. 그런데 이번에는 한글과 관련된 에러가 발생했습니다.\n\n(base) choonghyunryu@myWorld R % mail  \nMail version 8.1 6/6/93.  Type ? for help.\n\"/var/mail/choonghyunryu\": 1 message 1 new\n>N  1 choonghyunryu@myWorl  Thu Feb 10 08:20  51/2542  \"Cron <choonghyunryu@myWorld> /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_da\"\n? p\nMessage 1:\nFrom choonghyunryu@myWorld.local  Thu Feb 10 08:20:05 2022\nX-Original-To: choonghyunryu\nDelivered-To: choonghyunryu@myWorld.local\nFrom: choonghyunryu@myWorld.local (Cron Daemon)\nTo: choonghyunryu@myWorld.local\nSubject: Cron <choonghyunryu@myWorld> /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_data/R/excute_trade_apt.sh\nX-Cron-Env: <SHELL=/bin/sh>\nX-Cron-Env: <PATH=/usr/bin:/bin>\nX-Cron-Env: <LOGNAME=choonghyunryu>\nX-Cron-Env: <USER=choonghyunryu>\nDate: Thu, 10 Feb 2022 08:20:04 +0900 (KST)\n\nError: \n  Problem with `mutate()` column `<U+AC70><U+B798><U+AE08><U+C561>`.\n  i `<U+AC70><U+B798><U+AE08><U+C561> = stringr::str_remove(`\\uac70\\ub798\\uae08\\uc561`, \",\") %>% ...`.\n  x object '<U+AC70><U+B798><U+AE08><U+C561>' not found\nCaused by error in `stri_replace_first_regex()`: \n  object '<U+AC70><U+B798><U+AE08><U+C561>' not found\nBacktrace:\n     x\n  1. +-... %>% mutate(CREATE_DT = as.character(CREATE_DT))\n  2. +-dplyr::mutate(., CREATE_DT = as.character(CREATE_DT))\n  3. +-dplyr::mutate(., CREATE_DT = as.POSIXlt(date(), format = \"%a %b %d %H:%M:%S %Y\"))\n  4. +-purrr::map_df(...)\n  5. | \\-purrr::map(.x, .f, ...)\n  6. |   \\-.f(.x[[i]], ...)\n  7. |     \\-koscrap::trade_apt(...)\n  8. |       \\-doc %>% get_list() at koscrap/R/trade_apt.R:126:2\n  9. +-koscrap get_list(.)\n 10. | \\-... %>% ... at koscrap/R/trade_apt.R:66:4\n 11. +-dplyr::select(...)\n 12. +-dplyr::select(., -`<U+B144>`, -`<U+C6D4>`, -`<U+C77C>`)\n 13. +-dplyr::mutate(., `<U+AC74><U+CD95><U+B144><U+B3C4>` = as.integer(`<U+AC74><U+CD95><U+B144><U+B3C4>`))\n 14. +-dplyr::mutate(., `<U+CE35>` = as.integer(`<U+CE35>`))\n 15. +-dplyr::mutate(., DEAL_DATE = glue::glue(\"{<U+B144>}-{str_pad(<U+C6D4>, width = 2, pad = '0')}-{\\n                                  str_pad(<U+C77C>, width = 2, pad = '0')}\"))\n 16. +-dplyr::mutate(...)\n 17. +-dplyr:::mutate.data.frame(...)\n 18. | \\-dplyr:::mutate_cols(.data, ..., caller_env = caller_env())\n 19. |   +-base::withCallingHandlers(...)\n 20. |   \\-mask$eval_all_mutate(quo)\n 21. +-stringr::str_remove(`\\uac70\\ub798\\uae08\\uc561`, \",\") %>% ...\n 22. \\-stringr::str_remove(`<U+AC70><U+B798><U+AE08><U+C561>`, \",\")\n 23.   \\-stringr::str_replace(string, pattern, \"\")\n 24.     \\-stringi::stri_replace_first_regex(...)\nThere were 27 warnings (use warnings() to see them)\nExecution halted\n\ncron에서 한글 이슈가 발생하면, shell script에 다음처럼 export LANG=ko_KR.UTF-8구문을 삽입합니다.\n\n#!/bin/bash\n\n# 한글 환경 설정\nexport LANG=ko_KR.UTF-8\n\n# 오늘 날짜\nYMD=`date \"+%Y-%m-%d\"`\n# 프로젝트 디렉토리\nproject_dir='/Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data'\n# 작업 디렉토리\nwork_dir=\"$project_dir\"/collect_data\n\n# 로그 파일경로 및 이름\nlog_file=\"$work_dir\"/log/trade_apt_\"$YMD\".log\n\n/usr/local/bin/Rscript \"$work_dir\"/R/02_import_trade_apt.R > \"$log_file\"\n\ntidyverse 한글환경 Trouble Shooting\n한글 문제가 해결되었습니다. 그런데 이번에는 한글변수에서 에러가 발생했습니다. 애초 프로그램 언어에서의 사이드 이펙트(부작용, side effect)를 방지하기 위해서의 최선의 방법은 변수의 이름을 영문으로 정의하는 것이 암묵적인 룰인데, 국토교통부의 오픈 API는 변수 이름을 한글로 지정한 것이 안일한 결정이었습니다.\nR 환경이난 Shell 환경에는 분명 정상적으로 수행되던 코드가 cron에서 에러가 발생합니다. tidyverse 패키지군인 dplyr 패키지에서 한글변수를 찾지 못하는 에러가 발생한 것입니다.\n\n(base) choonghyunryu@myWorld R % mail\nMail version 8.1 6/6/93.  Type ? for help.\n\"/var/mail/choonghyunryu\": 1 message 1 new\n>N  1 choonghyunryu@myWorl  Thu Feb 10 08:28  50/2451  \"Cron <choonghyunryu@myWorld> /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_da\"\n? p\nMessage 1:\nFrom choonghyunryu@myWorld.local  Thu Feb 10 08:28:04 2022\nX-Original-To: choonghyunryu\nDelivered-To: choonghyunryu@myWorld.local\nFrom: choonghyunryu@myWorld.local (Cron Daemon)\nTo: choonghyunryu@myWorld.local\nSubject: Cron <choonghyunryu@myWorld> /Users/choonghyunryu/Documents/01_Personal/00_bitr/02_documents/stats_public_data/collect_data/R/excute_trade_apt.sh\nX-Cron-Env: <SHELL=/bin/sh>\nX-Cron-Env: <PATH=/usr/bin:/bin>\nX-Cron-Env: <LOGNAME=choonghyunryu>\nX-Cron-Env: <USER=choonghyunryu>\nDate: Thu, 10 Feb 2022 08:28:03 +0900 (KST)\n\nError: \n  Problem with `mutate()` column `거래금액`.\n  ℹ `거래금액 = stringr::str_remove(거래금액, \",\") %>% as.integer()`.\n  ✖ 객체 '거래금액'를 찾을 수 없습니다\nCaused by error in `stri_replace_first_regex()`: \n  객체 '거래금액'를 찾을 수 없습니다\nBacktrace:\n     ▆\n  1. ├─... %>% mutate(CREATE_DT = as.character(CREATE_DT))\n  2. ├─dplyr::mutate(., CREATE_DT = as.character(CREATE_DT))\n  3. ├─dplyr::mutate(., CREATE_DT = as.POSIXlt(date(), format = \"%a %b %d %H:%M:%S %Y\"))\n  4. ├─purrr::map_df(...)\n  5. │ └─purrr::map(.x, .f, ...)\n  6. │   └─.f(.x[[i]], ...)\n  7. │     └─koscrap::trade_apt(...)\n  8. │       └─doc %>% get_list() at koscrap/R/trade_apt.R:126:2\n  9. ├─koscrap get_list(.)\n 10. │ └─... %>% ... at koscrap/R/trade_apt.R:66:4\n 11. ├─dplyr::select(...)\n 12. ├─dplyr::select(., -년, -월, -일)\n 13. ├─dplyr::mutate(., 건축년도 = as.integer(건축년도))\n 14. ├─dplyr::mutate(., 층 = as.integer(층))\n 15. ├─dplyr::mutate(., DEAL_DATE = glue::glue(\"{년}-{str_pad(월, width = 2, pad = '0')}-{str_pad(일, width = 2, pad = '0')}\"))\n 16. ├─dplyr::mutate(...)\n 17. ├─dplyr:::mutate.data.frame(...)\n 18. │ └─dplyr:::mutate_cols(.data, ..., caller_env = caller_env())\n 19. │   ├─base::withCallingHandlers(...)\n 20. │   └─mask$eval_all_mutate(quo)\n 21. ├─stringr::str_remove(거래금액, \",\") %>% as.integer()\n 22. └─stringr::str_remove(거래금액, \",\")\n 23.   └─stringr::str_replace(string, pattern, \"\")\n 24.     └─stringi::stri_replace_first_regex(...)\n실행이 정지되었습니다\n\n여러 방법을 시도해보았고, 구글해보았지만 솔루션을 찾지 못했습니다. 그래서 다음처럼 아주 기본적으로 접근했습니다. 데이터 프레임을 만들고, 변수의 이름을 영문으로 고친 후 dplyr 구문을 사용하는 것으로 코드를 수정하였습니다.\nkoscape 패키지의 trade_apt() 함수 내에서의 get_list() 함수를 다음과 같이 수정하였습니다.\n\n이전 코드\n\n\n  get_list <- function(doc) {\n    doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame() %>%\n      mutate(거래금액 = as.integer(stringr::str_remove(거래금액, \",\"))) %>%\n      mutate(DEAL_DATE =\n               glue::glue(\"{년}-{str_pad(월, width = 2, pad = '0')}-{str_pad(일, width = 2, pad = '0')}\")) %>%\n      mutate(층 = as.integer(층)) %>%\n      mutate(건축년도 = as.integer(건축년도)) %>%\n      select(-년, -월, -일) %>%\n      select(\"LAWD_CD\"       = 지역코드,\n             DEAL_DATE,\n             \"SERIAL\"        = 일련번호,\n             \"DEAL_TYPE\"     = 거래유형,\n             \"BUILD_NM\"      = 아파트,\n             \"FLOOR\"         = 층,\n             \"BUILD_YEAR\"    = 건축년도,\n             \"AREA\"          = 전용면적,\n             \"AMOUNT\"        = 거래금액,\n             \"ROAD_CD\"       = 도로명코드,\n             \"ROAD_NM\"       = 도로명,\n             \"BUILD_MAJOR\"   = 도로명건물본번호코드,\n             \"BUILD_MINOR\"   = 도로명건물부번호코드,\n             \"ROAD_SEQ\"      = 도로명일련번호코드,\n             \"BASEMENT_FLAG\" = 도로명지상지하코드,\n             \"LAND_NO\"       = 지번,\n             \"DONG_NM\"       = 법정동,\n             \"DONG_MAJOR\"    = 법정동본번코드,\n             \"DONG_MINOR\"    = 법정동부번코드,\n             \"EUBMYNDONG_CD\" = 법정동읍면동코드,\n             \"DONG_LAND_NO\"  = 법정동지번코드,\n             \"DEALER_ADDR\"   = 중개사소재지,\n             \"CANCEL_DEAL\"   = 해제여부,\n             \"CANCEL_DATE\"   = 해제사유발생일)\n  }\n\n\n\n수정 코드\n\n\n  get_list <- function(doc) {\n    dframe <- doc %>%\n      XML::getNodeSet(\"//item\") %>%\n      XML::xmlToDataFrame()\n\n    if (NROW(dframe) == 0) {\n      return(data.frame())\n    }\n\n    vname <- c(\"AMOUNT\", \"DEAL_TYPE\", \"BUILD_YEAR\", \"YEAR\", \"ROAD_NM\",\n               \"BUILD_MAJOR\", \"BUILD_MINOR\", \"ROAD_ADMI\", \"ROAD_SEQ\",\n               \"BASEMENT_FLAG\", \"ROAD_CD\", \"DONG_NM\", \"DONG_MAJOR\",\n               \"DONG_MINOR\", \"DONG_ADMI\", \"EUBMYNDONG_CD\", \"DONG_LAND_NO\",\n               \"BUILD_NM\", \"MONTH\", \"DAY\", \"SERIAL\", \"AREA\", \"DEALER_ADDR\",\n               \"LAND_NO\", \"LAWD_CD\", \"FLOOR\", \"CANCEL_DATE\", \"CANCEL_DEAL\")\n    names(dframe) <- vname\n\n    dframe %>%\n      select(\"LAWD_CD\", \"YEAR\", \"MONTH\", \"DAY\", \"SERIAL\", \"DEAL_TYPE\",\n             \"BUILD_NM\", \"FLOOR\", \"BUILD_YEAR\", \"AREA\", \"AMOUNT\", \"ROAD_CD\",\n             \"ROAD_NM\", \"BUILD_MAJOR\", \"BUILD_MINOR\", \"ROAD_SEQ\",\n             \"BASEMENT_FLAG\", \"LAND_NO\", \"DONG_NM\", \"DONG_MAJOR\", \"DONG_MINOR\",\n             \"EUBMYNDONG_CD\", \"DONG_LAND_NO\", \"DEALER_ADDR\", \"CANCEL_DEAL\",\n             \"CANCEL_DATE\") %>%\n      mutate(DEAL_DATE = \n               glue::glue(\"{YEAR}-{str_pad(MONTH, width = 2, pad = '0')}-{str_pad(DAY, width = 2, pad = '0')}\")) %>%\n      mutate(AMOUNT = as.integer(stringr::str_remove(AMOUNT, \",\"))) %>%\n      mutate(FLOOR = as.integer(FLOOR)) %>%\n      mutate(BUILD_YEAR = as.integer(BUILD_YEAR)) %>%\n      select(LAWD_CD, DEAL_DATE, SERIAL:CANCEL_DATE)\n  }\n\n\n\n\n\nhttps://ko.wikipedia.org/wiki/일괄_처리 발췌↩︎\n",
      "last_modified": "2022-02-11T23:02:34+09:00"
    },
    {
      "path": "shiny_resources.html",
      "title": "학습 리소스",
      "description": "**수집데이터 분석** 애플리케이션 개발을 위한 Shiny, HTML, CSS 등에 대한 학습 리소스  \n",
      "author": [],
      "contents": "\n\nContents\nShiny 학습과 개발을 위한 리소스\nShiny 학습을 위한 리소스\n초보자를 위한 웹 개발 학습 리소스\nShiny 개발을 위한 리소스\n\n\nShiny 학습과 개발을 위한 리소스\nShiny 학습을 위한 리소스\nShiny 홈페이지 :\nhttps://shiny.rstudio.com/\n초급자 필수 사이트\n\nhtmltools 패키지 홈페이지 :\nhttps://rstudio.github.io/htmltools/\nshiny 앱에 html tags를 포함하는 기능\n\nshinydashboard 홈페이지 :\nhttps://rstudio.github.io/shinydashboard/\n초급자 필수 사이트\n\nMastering Shiny :\nhttps://mastering-shiny.org/\n중급자 이상\n\nBootstrap :\nhttps://getbootstrap.com/\n부트스트랩은 웹사이트를 쉽게 만들 수 있게 도와주는 HTML, CSS, JavaScript 프레임워크\nShiny는 내부적으로 Bootstrap와 인터페이스하여 반응형 앱을 구현하는 개발 도구\n\n초보자를 위한 웹 개발 학습 리소스\nHTML 홈페이지 :\nhttp://tcpschool.com/html/intro\nHTML(HyperText Markup Language)은 웹페이지에 내용을 기술하고 정의하는 데 사용\n\nCSS 홈페이지 :\nhttp://tcpschool.com/css/intro\nCSS(Cascading Style Sheets)는 웹페이지 콘텐츠의 모양이나 표현을 기술하는 데 사용\n\nJavaScript 홈페이지 :\nhttp://tcpschool.com/javascript/intro\nCSS(Cascading Style Sheets)는 웹페이지 콘텐츠 개발에 사용되는 스크립트 프로그래밍 언어\n\nShiny 개발을 위한 리소스\nFont Awesome :\nhttps://fontawesome.com/\n앱에 사용할 아이콘 선택을 위한 정보\n\n\n\n\n",
      "last_modified": "2022-02-11T23:02:35+09:00"
    },
    {
      "path": "submit_package.html",
      "title": "Submit R package to CRAN",
      "description": "몇 가지 Open API를 이용한 데이터 수집 로직을 구현해 봅니다.  \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2019-03-16",
      "contents": "\n\nContents\n개요\nR-devel 환경 만들기\nDownloading R-devel\nBuilding R-devel\nInstall R-devel\n\nCRAN에 패키지 등록하기\nbuild package\nsubmit package\n\n\n개요\nCRAN에 패키지를 submit하는 방법을 간단하게 다룹니다. 또한 CRAN에 패키지를 submit하기 위해서는 R-devel 환경에서도 무결성을 check해야 합니다. 생략할 수도 있지만, 특정 기능이 R development 버전에서 오류가 발생할 수도 있기 때문이다. 반드시 수행해야 합니다.\n본 note에서는 Mac OS X 버전의 R 3.5.2 환경에서 개발 버전을 설치하는 방법과 CRAN에 패키지를 submit하는 방법을 개괄적으로 다룹니다.\n\nR version 4.0.2 (2020-06-22)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS  10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] ggplot2_3.3.3        htmltools_0.5.1.9005 shiny_1.6.0         \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.1.1         xfun_0.23               \n [3] bslib_0.2.4.9002         purrr_0.3.4             \n [5] lattice_0.20-41          splines_4.0.2           \n [7] colorspace_2.0-1         vctrs_0.3.8             \n [9] generics_0.1.0           mgcv_1.8-31             \n[11] yaml_2.2.1               utf8_1.2.1              \n[13] rlang_0.99.0.9000        jquerylib_0.1.3         \n[15] later_1.3.0              pillar_1.6.1            \n[17] glue_1.6.0               withr_2.4.2             \n[19] DBI_1.1.1                lifecycle_1.0.1         \n[21] stringr_1.4.0            munsell_0.5.0           \n[23] gtable_0.3.0             evaluate_0.14           \n[25] labeling_0.4.2           knitr_1.33              \n[27] fastmap_1.1.0            httpuv_1.6.1            \n[29] fansi_0.5.0              highr_0.9               \n[31] Rcpp_1.0.7               xtable_1.8-4            \n[33] xaringanExtra_0.2.5.9000 promises_1.2.0.1        \n[35] scales_1.1.1             jsonlite_1.7.2          \n[37] farver_2.1.0             mime_0.10               \n[39] distill_1.2              digest_0.6.27           \n[41] stringi_1.6.2            bookdown_0.22           \n[43] dplyr_1.0.6              grid_4.0.2              \n[45] cli_3.0.0                tools_4.0.2             \n[47] magrittr_2.0.1           sass_0.3.1.9001         \n[49] tibble_3.1.2             crayon_1.4.1            \n[51] pkgconfig_2.0.3          downlit_0.2.1           \n[53] Matrix_1.2-18            ellipsis_0.3.2          \n[55] xml2_1.3.2               lubridate_1.7.10        \n[57] assertthat_0.2.1         rmarkdown_2.8           \n[59] rstudioapi_0.13          R6_2.5.1                \n[61] nlme_3.1-148             compiler_4.0.2          \n\nBuilding R-devel on Mac OS X를 참고하였습다.\nR-devel 환경 만들기\n아마 대부분의 R 사용자는 버전 번호는 다르지만, stable 버전의 R을 사용하고 있을 것입니다. 필자도 R을 CRAN에 제출하기 위해서 R development 버전을 설치하였습니다.\nDownloading R-devel\n다음처럼 https://stat.ethz.ch/R/daily URL에서 최신 R development 버전을 다운로드 합니다.:\n\n\n\nBuilding R-devel\n소스 파일의 압축을 풉니다.:\n\n\n\nconifg.site 파일의 FC 변수를 다음과 같이 정의합니다.\nF77=\"gfortran -arch x86_64\"\nFC=$F77\n소스 파일을 컴파일 합니다. CRAN에 패키지를 제출할 때 무결성 체크를 위한 목적으로만 사용하기 때문에 Gui 환경의 binary를 생성하지 않을 것입니다. configure 명령을 –without-x 옵션으로 수행하면 됩니다.\n\n\n\nInstall R-devel\nMac OS X 환경에서 prefix 변수의 값을 지정하지 않으면, 현재 설치된 stable 버전을 엎어칩니다. 그러므로 반드시 설치할 경로를 지정해야 합니다. 필자는 /usr/local/lib/R-devel 경로에 개발 버전을 설치하였습니다.\n\n\n\n이상으로 개발 버전을 설치하였다. 그리고 개발 버전은 다음과 같이 실행합니다.:\n\n\n\n다음처럼 심볼릭 링크를 생성하면 쉽게 사용할 수 있습니다.:\n\n\n\n이제는 콘솔에서 R-devel만 입력하면 R 개발 버전이 실행될 것입니다. 그러므로 다음과 같이 개발 버전 환경에서 패키지를 체크할 수 있습니다.\n\nR-devel CMD check –as-cran 패키지이름.tar.gz\n\nCRAN에 패키지 등록하기\nCRAN에 패키지를 등록하기 위해서는 몇 가지의 제약을 준수해야 합니다. 어쩌면 매우 까다로운 작업일 수도 있습니다. 아마 처음 패키지를 등록하는 패키지 개발자는 당황할 수도 있습니다.\nbuild package\n다음과 같이 패키지를 build합니다. 여기서는 dlookr 0.3.9 버전을 기준으로 설명합니다.\n예제에서 dlookr은 패키지 디렉토리를 의미합니다. R CMD build 명령로 패키지를 생성합니다.\n\n\n\n상기 명령이 수행되면 DESCRIPTION 파일에서 패키지의 버전 번호를 가져와 컴파일된 패키지 파일을 생성합니다. 그러므로 dlookr_0.3.9.tar.gz이라는 파일이 생성됩니다.\n패키지의 무결성을 진단하기 위해서 다음의 명령을 차례로 입력합니다.:\n\n\n\n오랜 시간동안 명령어가 수행됩니다. Error, Warning, Note 등이 발생된다면 원인을 찾아 수정해야 합니다. 그리고 그것들이 발생하지 않아야 CRAN에 제출할 수 있습니다.\nsubmit package\nhttps://cran.r-project.org/submit.html URL에서 패키지를 제출합니다. 이 URL은 그림처럼 개발자 이름, 이메일 주소 등을 입력하고 패키지 파일을 업로드할 수 있는 컴포넌트로 구성됩니다.\n\n\n\n(#fig:done_gtk)R 패키지 제출 화면\n\n\n\n정보를 입력하고, 파일을 업로드하면 면 단계 화면을 거치고 기술한 이메일 주소로 Submit 확인 메일이 발송됩니다. 발송된 메일의 URL에서 최종 제출 작업을 수행해야 합니다. 메일의 내용은 그림처럼 URL 링크를 포함하고 있습니다.\n\n\n\nFigure 1: R 패키지 제출 확인 메일\n\n\n\n패키지가 제출되면 몇 분 간격으로 접수되었다는 메일(그림)과 CRAN 사이트에 제출된 버전이 올라간다는 메일(그림)이 발송됩니다. 물론 제출된 패키지가 check에서 이상이 없었을 경우입니다.\n\n\n\nFigure 2: R 패키지 접수 확인 메일\n\n\n\n대부분의 정보는 DESCRIPTION 파일에 기재된 내용의 요약입니다.\n\n\n\n(#fig:goto_cran)R 패키지 등록 확인 메일\n\n\n\n접수 확인 메일 발송 후 정확히 30분 이후에 CRAN으로 패키지가 등록된다는 메일이 발송됨을 알 수 있습니다.\n\n\n\n",
      "last_modified": "2022-02-11T23:02:36+09:00"
    },
    {
      "path": "understand_markdown.html",
      "title": "마크다운 태그 이해하기",
      "description": "마크다운 태그로 다양한 서식의 문서를 문들 수 있습니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2021-11-12",
      "contents": "\n\nContents\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n튜토리얼의 범위\n\n마크다운의 이해\n마크다운은 무엇인가요?\n마크다운 태크 예제\n마크다운 에디터\n\n글자 형식 태그의 이해\n볼드체와 이탤릭체\n첨자\n취소문자\n\n문장 서식 태그의 이해\n헤더\n인용구\n글머리 기호와 번호 매기기\n수식 편집\n\n테이블 태그와 수평선의 이해\n테이블 그리기\n수평선 그리기\n\n이미지와 링크 삽입 태그의 이해\n이미지 삽입\n링크 삽입\n\n마크다운 튜토리얼\n글자 형식, 문장 서식 태그 설정하기\n테이블 그리고 이미지 넣기\n\n요약\n핸즈온 요약\nI can do it\n\n\n\n\n\n\n\n들어가기\n이제 당신은 에디터가 되고 작가가 됩니다.\n\n마크다운 태그를 이해하면, 마크다운 조판을 통해 멋진 글을 문서로 만들고 책을 출판할 수도 있습니다.\n\n마크다운은 쉽고 빠릅니다. 물론 학습도 빠르겠지요.\n\n\nR 마크다운 문서의 이해\nR 마크다운 문서의 분해\n앞서 만들었던 첫 R 마크다운 문서를 분해하면 다음과 같습니다.\nR 마크다운 문서의 분해YAML 헤더\nR 마크다운의 헤더 영역으로, 출력 문서를 세부적으로 제어합니다.\n\nR 코드 청크\n수행할 R 코드를 포함한 영역입니다.\n\n마크다운 태그를 포함한 텍스트\n문서의 서식과 텍스트를 정의하는 영역입니다.\n\n튜토리얼의 범위\n이 튜토리얼은 R 마크다운 문서의 분해 중에서의 마크다운 태그를 이해할 목적으로 진행합니다. 동일한 마크다운 문서로 어떻게 서식이 적용된 그럴싸한 문서를 만들 수 있는지, 실습을 통해 편집자가 되어보세요.\n마크다운의 이해\n마크다운은 무엇인가요?\n마크다운(Markdown)은 일반 텍스트 기반의 경량 마크업 언어입니다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용됩니다.\n마크다운 태크 예제\n이미 우리는 마크다운 태크를 경험했습니다.\n## R Markdown\n앞에서 우리는 샾(#)을 두개 사용해서 “R Markdown”을 텍스트가 아니라 타이틀로 출력했었습니다.\n마크다운 에디터\n마크다운은 R 마크다운에서만 사용하는 R 전유물이 아닙니다. 많은 영역에서 마크다운을 사용하며, 별도로 마크다운 문서를 작성하거나 결과를 표현해주는 에디터들도 많습니다. R 환경에서도 마크다운을 사용하는 여러 패키지들이 있습니다.\n그런데 마크다운은 마크다운을 인식하는 에디터마다 조금씩 문법이 상이합니다. 또한 관련 패키지마다 세부적으로 문법이 조금씩 차이가 나며, 표현되는 문서도 다소 차이가 있을 수 있습니다.\n\n\n\n\n주의\n\n마크다운은 에디터마다, 또한 R 패키지마다 다소 차이가 있습니다. 이것이 마크다운의 단점 중의 하나입니다. 본 튜토리얼이 다른 마크다운 설명서와 다소 차이가 있을 수 있습니다. distill 패키지로 작성한 본 튜토리얼은 YAML 헤더의 output: 태그에 distill::distill_article을 사용했음을 밝혀둡니다. 그래서 html_document와도 다소 차이가 있을 수 있습니다. 그러나 차이가 미미해서 마크다운을 이해하는 교재로서 큰 문제는 없습니다.\n\nR 마크다운에서 차이가 나는 가장 큰 이유는 테마때문입니다. 패키지마다 테마가 차이가 있어서 몇몇 태그의 표현되는 모습이 다를 수 있습니다. 테마는 사용자가 변경할 수 있으나, 본 튜토리얼의 범위를 넘어 언급하지 않겠습니다.\n\n\n글자 형식 태그의 이해\n볼드체와 이탤릭체\n볼드체는 **나 __를 대상이 될 텍스트의 앞과 뒤에 표시합니다.\n에스터리스크(*)나 언더라인(_) 두개\n\n이탤릭체는 *나 _를 대상이 될 텍스트의 앞과 뒤에 표시합니다.\n에스터리스크(*)나 언더라인(_) 하나\n\n\n볼드체와 이탤릭체를 표현할 때, 언더라인 형식은 사용하지 않는 것이 좋습니다. 경우에 따라서 부작용으로 작동되지 않을 수 있습니다. 이 문서를 만든 distill에서는 동작하지 않았습니다.\n\n\n마크다운 예제\n**마크다운(Markdown)**은 일반 *텍스트 기반*의 경량 **마크업 언어**입니다.\n\n__마크다운(Markdown)__은 일반 _텍스트 기반_의 경량 __마크업 언어__입니다.\n출력 결과\n마크다운(Markdown)은 일반 텍스트 기반의 경량 마크업 언어입니다.\n__마크다운(Markdown)__은 일반 _텍스트 기반_의 경량 __마크업 언어__입니다.\n\n\n첨자\n윗첨자는 ^를 대상이 될 텍스트의 앞과 뒤에 표시합니다.\n아래첨자는 ~를 대상이 될 텍스트의 앞과 뒤에 표시합니다.\n\n\n마크다운 예제\nE = mc^2^에 의하면 에너지는 질량에 비례한다.\n\nY~i~ = X~i~ + 3 \n출력 결과\nE = mc2에 의하면 에너지는 질량에 비례한다.\nYi = Xi + 3\n\n\n취소문자\n취소문자는 ~ 두개를 대상이 될 텍스트의 앞과 뒤에 표시합니다.\n\n\n마크다운 예제\n~~하루에 30분 달리기~~\n일주일에 ~~5번~~ 산책하기\n\n출력 결과\n하루에 30분 달리기\n일주일에 5번 산책하기\n\n\n문장 서식 태그의 이해\n헤더\n헤더는 주제목 및 부제목 등 제목을 설정할 때 사용합니다. 한글 문서에서의 장, 절 등을, 영문 문서에는 chapter, subject, sub-subject 등을 구분하기 위한 조판 형식입니다.\n문서를 주제별로 계층적인 구조로 나누는 분류 체계라 할 수 있습니다.\n마크다운에서는 헤더(header)라고 부릅니다. header 1 부터 header 6까지 있으며, 숫자가 작을 수록 글자의 크기가 큰 헤더가 됩니다. 헤더를 조판하기 위해서는 숫자에 해당하는 개수만큼의 ’#’을 사용합니다.\nR 마크다운에서는 통상적으로 제일 큰 타이틀인 chapter(장)에 해당하는 헤더에 header 2를 사용합니다. 즉 ’##’를 사용합니다.\n\n본 튜토리얼에서는 몇몇 개의 헤더에 CSS로 서식을 변경했습니다. 모양과 색상 및 대소문자의 형식이 다를 수 있으니, 글자의 크기만 비교하세요.\n\n\n\n마크다운 예제\n# Header 1\n## Header 2\n### Header 3\n#### Header 4\n##### Header 5\n###### Header 6\n\n출력 결과\nHeader 1\nHeader 2\nHeader 3\nHeader 4\nHeader 5\nHeader 6\n\n\n\n인용구\n인용구는 블록 쿼트 (blockquote)로 부르며, 인용문을 별도로 강조하기 위해서 사용합니다.\n마크다운에서 인용구는 ‘>’ 문자로 정의합니다.\n\n\n마크다운 예제\n**R 마크다운의 의의**는 무엇일까요?\n> \"R 마크다운은 재현 가능한 연구를 지원하는 훌륭한 솔루션입니다.\" \n\n출력 결과\nR 마크다운의 의의는 무엇일까요?\n\n“R 마크다운은 재현 가능한 연구를 지원하는 훌륭한 솔루션입니다.”\n\n\n\n글머리 기호와 번호 매기기\n목록을 표현하기 위한 글머리 문자는 불릿(bullet)이라 부르며, 주목도를 높이기 위해서 텍스트 앞에 삽입하는 기호입니다. 기호 대신에 숫자를 넣는 방법도 있습니다. 이 경우에는 순서의 의미가 부여되기도 합니다.\n글머리 문자는 라인의 맨 앞에 ’*’를 삽입하고 텍스트를 기술합니다. 엔터로 줄바꿈하여, 둘째, 셋째 글머리를 기술합니다.\n기호 대신에 숫자를 넣는 번호 매기기는 ’*’ 대신에 숫자 + “.”로 표현합니다. 숫자는 순서에 맞게 1, 2, 3과 같이 실제 순번을 기술할 수도 있고 임의의 한 숫자로 동일하게 사용할 수도 있습니다. 중요한 것은 번호는 첫째 글머리에 기술한 숫자부터 시작해서 1씩 증가한다는 점입니다. 그래서 통상적으로 임의의 한 숫자로 1을 사용합니다.\n\n\n마크다운 예제\nR 마크다운의 기술적 요소는 다음과 같음:\n\n* knitr\n* markdown\n* pandoc\n\n출력 결과\nR 마크다운의 기술적 요소는 다음과 같음:\nknitr\nmarkdown\npandoc\n\n\n\n마크다운 예제\nR 마크다운 문서를 작성하는 방법은 다음과 같음:\n\n1. 새파일 작성 메뉴를 이용해서 R 마크다운 템플리트를 생성한다.\n1. R 코드 청크에 R 코드를 작성한다.\n1. 코드의 설명과 실행 결과의 설명을 마크다운 태그를 이용해서 작성한다.\n1. YAML 헤더를 수정하여 생성한 조판 서식을 조정한다.\n1. \"knit\"를 눌러 문서를 생성한다. \n\n출력 결과\nR 마크다운 문서를 작성하는 방법은 다음과 같음:\n새파일 작성 메뉴를 이용해서 R 마크다운 템플리트를 생성한다.\nR 코드 청크에 R 코드를 작성한다.\n코드의 설명과 실행 결과의 설명을 마크다운 태그를 이용해서 작성한다.\nYAML 헤더를 수정하여 생성한 조판 서식을 조정한다.\n“knit”를 눌러 문서를 생성한다.\n\n\n불릿이 있다면, 서브 불릿(sub bullet)이 있겠죠. 서브 불릿은 탭이나 스페이스 두어개로 들여쓰기하면 됩니다. 서브 불릿으로는 ’*’ 대신에 ’+’를 사용합니다.\n\n마크다운 예제\nR 마크다운의 기술적 요소는 다음과 같음:\n\n* knitr\n  + 청크를 실행함\n    + R 소스 청크 외에 bash, python 청크도 가능\n* markdown\n  + 마크다운 문서를 조판함\n* pandoc\n  + PDF나 HTML 등 다른 문서로 변환함\n\n출력 결과\nR 마크다운의 기술적 요소는 다음과 같음:\nknitr\n청크를 실행함\nR 소스 청크 외에 bash, python 청크도 가능\n\n\nmarkdown\n마크다운 문서를 조판함\n\npandoc\nPDF나 HTML 등 다른 문서로 변환함\n\n\n\n번호 매기기도 같은 방법입니다.\n\n마크다운 예제\nR 마크다운 문서를 작성하는 방법은 다음과 같음:\n\n1. 새파일 작성 메뉴를 이용해서 R 마크다운 템플리트를 생성한다.\n    1. 에디터에서 그냥 작성해도 무방하다.\n1. R 코드 청크에 R 코드를 작성한다.\n    1. 코드청크 삽입 메뉴 아이콘을 누른다.\n    1. 옵션을 추가하거나 변경합니다.\n1. 코드의 설명과 실행 결과의 설명을 마크다운 태그를 이용해서 작성한다.\n    1. 마크 다운이 아닌 텍스트만 사용해도 무방하다.\n    1. 가급적 친절하게 자세히 기술한다.\n1. YAML 헤더를 수정하여 생성한 파과 조판 서식을 조정한다.\n1. \"knit\"를 눌러 문서를 생성한다. \n\n출력 결과\nR 마크다운 문서를 작성하는 방법은 다음과 같음:\n새파일 작성 메뉴를 이용해서 R 마크다운 템플리트를 생성한다.\n에디터에서 그냥 작성해도 무방하다.\n\nR 코드 청크에 R 코드를 작성한다.\n코드청크 삽입 메뉴 아이콘을 누른다.\n옵션을 추가하거나 변경합니다.\n\n코드의 설명과 실행 결과의 설명을 마크다운 태그를 이용해서 작성한다.\n마크 다운이 아닌 텍스트만 사용해도 무방하다.\n가급적 친절하게 자세히 기술한다.\n\nYAML 헤더를 수정하여 생성한 파과 조판 서식을 조정한다.\n“knit”를 눌러 문서를 생성한다.\n\n\n수식 편집\nLaTeX에서 지원하는 수식의 출력을 지원합니다. ’$’로 수식의 시작과 종료를 알려줘야 합니다.\nLaTeX의 수식 태그를 모를 경우 위키백과:TeX 문법을 참고해서 작성합니다.\n\n\n마크다운 예제\n$E = m \\times c^{2}$에 의하면 에너지는 질량에 비례한다.\n\n$\\sigma = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N (x_i -\\mu)^2}$\n\n출력 결과\n\\(E = m \\times c^{2}\\)에 의하면 에너지는 질량에 비례한다.\n\\(\\sigma = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N (x_i -\\mu)^2}\\)\n\n\n테이블 태그와 수평선의 이해\n테이블 그리기\n도표(테이블)을 그리는 것은 다소 성가십니다. 텍스트로 도표의 모양을 그려줘야 하기 때문입니다.\n다음의 형식으로 도표를 그립니다.\nFirst Header  | Second Header\n--------------|-------------\nCell 1-1      | Cell 1-2\nCell 2-1      | Cell 2-2 \n파이프 문자 ’|’는 세로 줄을 의미합니다. 컬럼을 구분하는 구분자로 위 형식에서는 두 컬럼을 분리했습니다.\n\n\n마크다운 예제\nFirst Header  | Second Header\n--------------|-------------\nCell 1-1      | Cell 1-2\nCell 2-1      | Cell 2-2 \n출력 결과\nFirst Header\nSecond Header\nCell 1-1\nCell 1-2\nCell 2-1\nCell 2-2\n\n\n컬럼의 문자열을 정렬할 수 도 있습니다.\n기본값은 좌측 정렬이며, 정렬을 위해서는 헤더를 구분하는 하이픈(-)에 콜론(:)을 사용합니다. 다음의 사례는 첫 컬럼부터 각각 우측 정렬, 좌측 정렬, 가운데 정렬을 의미합니다. 콜론의 위치를 주의깊게 살펴 보시기 바랍니다.\nFirst Header  | Second Header | Third Header\n-------------:|:--------------|:------------:\nCell 1-1      | Cell 1-2      | Cell 1-3  \nCell 2-1      | Cell 2-2      | Cell 2-3  \n\n\n마크다운 예제\nFirst Header  | Second Header | Third Header\n--------------|---------------|--------------\nCell 1-1      | Cell 1-2      | Cell 1-3  \nCell 2-1      | Cell 2-2      | Cell 2-3  \n\n사용자가 정렬 변경하기\n\n우측 정렬     | 좌측 정렬     | 가운데 정렬\n-------------:|:--------------|:------------:\nCell 1-1      | Cell 1-2      | Cell 1-3  \nCell 2-1      | Cell 2-2      | Cell 2-3  \n\n출력 결과\nFirst Header\nSecond Header\nThird Header\nCell 1-1\nCell 1-2\nCell 1-3\nCell 2-1\nCell 2-2\nCell 2-3\n사용자가 정렬 변경하기\n우측 정렬\n좌측 정렬\n가운데 정렬\nCell 1-1\nCell 1-2\nCell 1-3\nCell 2-1\nCell 2-2\nCell 2-3\n\n\n수평선 그리기\n경우에 따라서 수평선을 그려 앞 부분과 뒷 부분을 명확이 구분할 필요가 있습니다.\n아스터리스크(*)이나 하이픈(-) 문자를 3개 이상을 연속으로 기술하면 수평선이 만들어 집니다.\n***\n---\n\n\n마크다운 예제\n앞 문장\n\n***\n\n가운데 문장\n\n------\n\n뒷 문장\n\n출력 결과\n앞 문장\n가운데 문장\n뒷 문장\n\n\n이미지와 링크 삽입 태그의 이해\n이미지 삽입\n\n\n\n\n주의\n\n마크다운의 이미지 삽입 태그는 마크다운 에디터별로 차이가 많습니다. 특히 마크다운 문법 중 이미지 옵션에 관련해서는 R 마크다운에서 적용되지 않는 경우가 많습니다.\n\n\n\n이미지 삽입 태그는 다음 문법을 따릅니다.\n![이미지 캡션](이미지 파일의 경로)\n만약 이미지의 캡션을 사용하지 않을 경우에는\n![](이미지 파일의 경로)\n와 같이 캡션을 넣지 않습니다.\n\n\n마크다운 예제\nimg 디렉토리에 markdwon.png 파일이 위치합니다. 이 파일은 마크다운의 로고입니다. 이 파일을 문서에 포함하기 위해서는 다음 태그를 사용합니다.\n\n![마크다운 로고](img/markdown.png)\n출력 결과\n마크다운 로고마크다운 로고 이미지가 제법 큽니다. 깜짝 놀랐습니다. 이미 파일에 저장된 원 사이즈대로 출력되었습니다. 조금 줄여볼까요?\n\n\n이미지 사이즈 조절\n이미지의 사이즈를 조절하기 위해서는 다음의 옵션을 사용합니다.\n![마크다운 로고](이미지 파일의 경로){: width=\"\" height=\"\"}\n\nwidth와 height에 너비와 높이를 지정합니다.\n너비와 높이는 두 가지 포맷을 지원합니다.\n픽셀을 의미하는 ’px’를 붙이거나 생략해서 필셀 단위의 기술\n“100px” 혹은 “100”\n\n차지할 수 있는 전체 범위를 100%로 감안하여 백분율을 기술\n“50%”\n\n\n마크다운 예제\n너비와 높이를 각각 100 픽셀의 크기로 이미지 사이즈를 조정합니다.\n![마크다운 로고](이미지 파일의 경로){: width=\"100\" height=\"100\"}\n출력 결과\n{: width=“100” height=“100”}\n옵션이 적용되지 않았습니다. 당연히 옵션에 대한 태그가 해석되지 않았기에 화면에 출력됩니다. 그런데, 왜 이미지 사이즈가 작아졌을까요?\n표현할 화면에 이미지와 태그가 한 줄에 출력되어야해서 이미지가 태그 텍스트의 범위만큼 줄어든 것입니다.\n마크다운 문법의 호환성 불일치가 발생하였습니다.\n\n\n\n부작용 없이 사이즈를 조절하기 위해서는 마크다운 태그가 아닌, 다음의 HTML 태그를 사용합니다.\n\n<img src=\"이미지 파일의 경로\" width=\"\" height=\"\">\n\n다시 너비와 높이를 각각 100 픽셀의 크기로 이미지 사이지를 조정합니다. 로고가 길죽한 모양이기 때문에, 이 옵션으로는 이상한 모양의 이미지가 출력될 것입니다.\n\n마크다운 예제\n<img src=\"img/markdown.png\" width=\"100\" height=\"100\">\n출력 결과\n\n\n\n궁극의 방법을 소개합니다. R 소스 청크를 이용하는 방법입니다. 그러나 이 방법은 아쉽게도 캡션을 사용하면 충돌이 발생합니다.\n\n\n마크다운 예제\n너비와 높이 비율을 고정하고 크기를 화면 영역의 50%로 사이즈를 조정합니다. 또한 이미지를 가운데 정렬합니다.\n```{r, echo=FALSE, out.width = \"50%\", fig.align=\"center\"}\nknitr::include_graphics(\"img/markdown.png\")\n```\n출력 결과\n\n\n\n\n링크 삽입\n링크 삽입 태그는 다음 이미지 삽입 태그와 문법이 유사합니다.\n[URL을 링크 걸 텍스트](링크 걸 URL)\n\n\n마크다운 예제\n[R Markdown 홈페이지](https://rmarkdown.rstudio.com/)\n출력 결과\nR Markdown 홈페이지\n\n\n마크다운 튜토리얼\n글자 형식, 문장 서식 태그 설정하기\n1. 다음 마크다운 출력물을 만들 마크다운 문서를 작성해 보세요.\n\n위키백과 마크다운 페이지를 일부 차용했습니다.\n서식은 임의로 편집하였습니다.\n\n\n\n\n힌트 보기\n제목 헤더는 header 2를 적용했습니다.\n강조문자 (볼드체)를 몇 개 사용했습니다.\n인용구를 사용했습니다.\n이미지의 사이즈는 30%이며, 좌측정렬을 수행했습니다.\n모범 답안\n## 마크다운\n\n```{r, echo=FALSE, out.width = \"30%\", fig.align=\"left\"}\nknitr::include_graphics(\"img/markdown.png\")\n```\n\n**마크다운(markdown)**은 일반 텍스트 기반의 경량 마크업 언어다. 일반 텍스트로 서식이 있는 문서를 작성하는 데 사용되며, \n일반 마크업 언어에 비해 문법이 쉽고 간단한 것이 특징이다. **HTML**과 **리치 텍스트(RTF)** 등 서식 문서로 쉽게 변환되기 \n때문에 응용 소프트웨어와 함께 배포되는 README 파일이나 온라인 게시물 등에 많이 사용된다.\n\n> 마크다운은 일반 텍스트 기반의 경량 마크업 언어다. - 위키피디아\n\n## 역사\n존 그루버는 2004년에 문법 면에서 에런 스워츠와 중대한 협업을 통해 마크다운 언어를 만들었으며, \n사람들이 읽기 쉽고 쓰기 쉬운 플레인 텍스트 포맷을 사용하여 쓸 수 있으면서 구조적으로 유효한 \nXHTML(또는 HTML)로 선택적 변환이 가능하게 하는 것이 목표이다.\n\n\n테이블 그리고 이미지 넣기\n2. 다음 테이블을 만들어 보세요\n\n이미지는 다음 링크에서 다운로드 하세요.\nknitr.png\nrmarkdown.png\nmarkdown.png\n\n테이블 안의 이미지는 사이즈를 조절하지 않습니다.\n\n\nknitr\nrmarkdown\nmarkdown\n\n\n\nR 소스 청크를 해석\nYAML 헤더를 해석하고 문서 생성\n텍스트에 서식을 부여, 문서 조판\nR 패키지\n청크 실행\n\nR 패키지\nPandoc 연동\n\nR 패키지 아님\n문서 조판\n\n\n\n힌트 보기\n이미지는 다음 태그로 출력합니다.\n![](이미지 파일의 경로)\n표 안에 머리글 기호를 넣습니다.\n모범 답안\n+---------------------+--------------------------------+---------------------------------+\n| knitr               | rmarkdown                      | markdown                        |\n+=====================+================================+=================================+\n| ![](img/knitr.png)  | ![](img/rmarkdown.png)         | ![](img/markdown.png)           |\n+---------------------+--------------------------------+---------------------------------+\n| R 소스 청크를 해석      | YAML 헤더를 해석하고 문서 생성       | 텍스트에 서식을 부여, 문서 조판        |\n+---------------------+--------------------------------+---------------------------------+\n| * R 패키지            | * R 패키지                      | * R 패키지 아님                    |\n| * 청크 실행           | * Pandoc 연동                   | * 문서 조판                       |\n+---------------------+--------------------------------+---------------------------------+\n\n\n요약\n핸즈온 요약\n마크다운 글자 형식 태그와 문장 서식 태그를 이해했습니다.\n마크다운으로 테이블을 그렸습니다.\n마크다운 문서에 이미지를 삽입하고 링크를 걸었습니다.\nI can do it\n마크다운 문서를 작성할 수 있어, R 마크다운 문서에 여러 서식을 지정할 수 있습니다.\n\n\n\n",
      "last_modified": "2022-02-11T23:02:37+09:00"
    },
    {
      "path": "use_distill.html",
      "title": "distill 패키지의 활용",
      "description": "distill 패키지를 사용해서 Knowledge Base 구축을 위한 홈페이지를 만듭니다. \n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io/"
        }
      ],
      "date": "2022-02-01",
      "contents": "\n\nContents\n들어가기\ndistill\nR 마크다운 문서의 이해\n웹 사이트 만들기\nTemplate 파일의 이해\n\n설정 최적화하기\n웹 페이지 출력 경로의 변경\n테마 변경하기\nfooter 적용하기\nbibliography 적용하기\n이 페이지의 YAML 헤더\n\nR Markdown의 이해\n\n\n\n\n\n\n들어가기\ndistill은 과학 및 기술문서를 작성하기 위한 R Markdown 포맷입니다.\n\nR Markdown은 재현가능한 연구나 개인과 조직의 Knowledge Base 구축을 위해 유용하게 사용됩니다.\n\n이제 여러분은 R Markdownd 기반의 distill으로 여러분의 저술 활동에 날개를 달게 됩니다.\n\n\n들어가기\n재현가능한 연구(Reproducible Research)라는 용어가 생소할 수 있으나 R world에서는 제법 회자되는 용어입니다. 공개한 연구의 결과물이 재현되고 검증될 수 있도록 하는 것을 의미합니다. 이 방법은 결국 연구가 발전하는 방향으로 재창조되는 결실을 가져옵니다. 이를 위해서는 데이터 분석의 방법을 실험 데이터에 연결하여 재현 검증될 수 있는 체계를 구축해야 합니다.\n재현가능한 연구를 이해하기 쉬운 사례로 설명하겠습니다. 데이터 입출력 및 분석 방법의 로직과 분석 결과를 표현하는 R 스크립트를 R 마크다운 문서에 정리합니다. 물론 연구에 대한 자세한 설명과 결과 해석이 문서에 포함되어 있고, 원시 데이터도 별도로 포함합니다. 이 연구 결과를 RStudio 프로젝트나 R 패키지로 배포하면 누구나 동일한 결과를 재현할 수 있게 됩니다.\n공개한 연구 자료에는 데이터, 분석을 위한 R 코드 및 과정의 설명과 결과의 해석 모두 포함되어야 합니다. 그러므로 재현가능한 연구는 오픈소스 정신이 깃들여 있는 셈입니다.\nCRAN Task View: Reproducible Research 페이지를 보면 R에서 재현가능한 연구를 지원하는 에코 시스템이 어마어마하게 많고 다양한 기능을 가지고 있음에 놀랄 것입니다. 다수의 R 패키지가 여러 기능을 통해서 재현가능한 연구를 지원합니다만, R 마크다운 문서가 정적이거나 동적인 HTML 문서의 보고서로 만들어지거나 혹은 LaTeX을 이용해서 PDF 문서로 만들어지는 것이 눈에 잡히는 재현가능한 연구의 도구입니다.\n광의적으로는 rmarkdown, knitr, blogdown, bookdown, distill도 재현가능한 연구를 지원하는 패키지입니다.\ndistill\ndistill 홈페이지인 https://rstudio.github.io/distill/ (Allaire et al. 2018)를 방문하면, distill의 기능을 익힐 수 있습니다. 헥스로고는 다음과 같이 물방울 이미지를 포함하고 있습니다.\n다음에 distill의 재현가능한 연구에 최적화된 대표적인 기능을 정리해 봅니다.\nRefrences의 표시\n페이지 하단에 참조물을 표현합니다.\nBibtex, YAML format의 bibliography을 지원합니다.\n\nCitation의 표시\n페이지 하단에 Citation을 표현합니다.\n페이지 YAML 헤더를 읽어 Citation을 만들어줍니다.\n\n이 포스트는 기술적인 노하우나 경험을 담고 있지는 않지만, 이해의 측면에서 distill의 재현가능한 연구에 최적화된 대표적인 기능을 표현해 보았습니다.\nR 마크다운 문서의 이해\n웹 사이트 만들기\ndistill 패키지의 create_website() 함수로 웹 사이트의 골격(skeleton) 만듧니다.\n디렉토리 경로는 “./workshop_lecture”\n웹사이트의 타이틀은 “애플리케이션 서버 구축을 위한 R 워크샾”\n다음 스크립트로 웹 사이트 구축을 위한 골격을 만듧니다.\n\n\ndistill::create_website(\n  dir = \"./workshop_lecture\", \n  title = \"애플리케이션 서버 구축을 위한 R 워크샾\"\n)\n\n\n\nTemplate 파일의 이해\ncreate_website() 함수를 실행하면 다음처럼 몇 개의 파일과 디렉토리가 만들어집니다.\n\n\n\n\n대표적인 파일의 내용은 다음과 같습니다. 이제 여러분은 이 파일을 기초로 해서, 기능을 확장하고 내용을 채워나가야 합니다.\n\n_site.yml\nname: \"workshop_lecture\"\ntitle: \"애플리케이션 서버 구축을 위한 R 워크샾\"\ndescription: |\n  애플리케이션 서버 구축을 위한 R 워크샾\noutput_dir: \"_site\"\nnavbar:\n  right:\n    - text: \"Home\"\n      href: index.html\n    - text: \"About\"\n      href: about.html\noutput: distill::distill_article\n\nindex.Rmd\n---\ntitle: \"애플리케이션 서버 구축을 위한 R 워크샾\"\ndescription: |\n  Welcome to the website. I hope you enjoy it!\nsite: distill::distill_website\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE)\n\n# Learn more about creating websites with Distill at:\n# https://rstudio.github.io/distill/website.html\n\n```\nabount.Rmd\n---\ntitle: \"About this site\"\ndescription: |\n  Some additional details about the website\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE)\n```\n\n설정 최적화하기\n기본 템플리트를 사용자 환경에 최적화하는 몇 가지 방법을 다룹니다.\n웹 페이지 출력 경로의 변경\n무료로 정적 웹 페이지를 온라인에 배포하는 대표적인 두 가지 방법이 있습니다.\nnetlify\ngithub\n두 서비스는 각각 서로 다른 웹 페이지 출력 경로의 이름을 사용합니다.\nnetlify는 _site를 사용하고, github는 docs를 사용합니다.\ndistill은 기본 netlify에 서비스를 배포하는 것을 염두에 두고 “_site”를 웹 페이지 출력 경로로 사용합니다. 그러므로 github에 배포하기 위해서는 다음처럼 _site.yml 파일에서 output_dir을 수정합니다.\n\nnetlify\nname: \"workshop_lecture\"\ntitle: \"애플리케이션 서버 구축을 위한 R 워크샾\"\ndescription: |\n  애플리케이션 서버 구축을 위한 R 워크샾\noutput_dir: \"_site\"\nnavbar:\n  right:\n    - text: \"Home\"\n      href: index.html\n    - text: \"About\"\n      href: about.html\noutput: distill::distill_article\n\ngithub\nname: \"workshop_lecture\"\ntitle: \"애플리케이션 서버 구축을 위한 R 워크샾\"\ndescription: |\n  애플리케이션 서버 구축을 위한 R 워크샾\noutput_dir: \"docs\"\nnavbar:\n  right:\n    - text: \"Home\"\n      href: index.html\n    - text: \"About\"\n      href: about.html\noutput: distill::distill_article\n\n\n테마 변경하기\n웹 페이지의 테마(theme)를 변경할 수 있습니다. 본 웹 페이지는 테마를 위한 CSS1 파일로 theme.css 를 만들었습니다.\n이 파일을 적용하기 위해서는 R Markdown 파일인 _site.yml를 변경해야 합니다.\nYAML 헤더는 YAML 이해하기를 참고하세요.\nfooter 적용하기\nfooter는 웹 페이지에 공통적으로 적용되는 페이지 하단의 컨텐츠입니다.\nfooter를 footer.html HTML 파일로 만들어서 _site.yml에 설정합니다.\nbibliography 적용하기\nReference를 정의하기 위한 bibliography는 biblio.bib 파일에 정의하고 *.Rmd의 YAML 헤더에 설정합니다.\n이 페이지의 YAML 헤더\n이 페이지의 YAML 헤더는 다음과 같습니다.\n---\ntitle: \"distill 패키지의 활용\"\ndescription: |\n  distill 패키지를 사용해서 Knowledge Base 구축을 위한 홈페이지를 만듭니다. \nsite: distill::distill_website\noutput:\n  distill::distill_article:\n    toc: true\n    toc_depth: 3  \n    theme: theme.css\n    includes:\n      after_body: footer.html    \nauthor:\n  - name: 유충현 \n    url: https://choonghyunryu.github.io/\n    affiliation: 한화생명\nbibliography: biblio.bib    \ndate: 2022-02-01     \n---\nR Markdown의 이해\nR Markdown을 이해하기 위해서 R Markdown의 이해를 학습하기 바랍니다.\n\n\n\nAllaire, JJ, Rich Iannone, Alison Presmanes Hill, and Yihui Xie. 2018. “Distill for r Markdown.” https://rstudio.github.io/distill.\n\n\n캐스케이딩 스타일 시트(Cascading Style Sheets, CSS)는 마크업 언어가 실제 표시되는 방법을 기술하는 스타일 언어(style sheet language)이다. https://ko.wikipedia.org/wiki/CSS↩︎\n",
      "last_modified": "2022-02-11T23:02:39+09:00"
    },
    {
      "path": "userinterface.html",
      "title": "사용자 인터페이스 만들기",
      "description": "사용자 인터페이스(UI)를 이해합니다. **page**, **layout**, **panel**을 숙지해야 합니다.\n",
      "author": [
        {
          "name": "유충현",
          "url": "https://choonghyunryu.github.io"
        }
      ],
      "date": "2022-02-05",
      "contents": "\n\nContents\nShiny 사용자 인터페이스\nShiny 앱 Skeleton\n페이지\nshiny 페이지\nshinydashboard 페이지\n\n레이아웃과 패널\n레이아웃\n패널\n레이아웃과 패널의 배치 예제\n\nHTML 태그\nHTML 태그를 만드는 함수\nHTML 태그를 사용 예제\n\n\ntutorial\nUI 뼈대 만들기 tutorial\nShiny 공식 tutorial 페이지\n추가 예제 실행해 보기\n\n\n\n\n\n\n\n들어가기\n사용자 인터페이스는\n사용자와 컴퓨터를 연결해주는 메신저입니다.\n사용자의 의도를 Shiny에게 전달하는\n의도 파악\n과 R의 수행결과를 Shiny를 통해\n내용의 전달\n을 도와줍니다.\n\n사용자 인터페이스를 이해하는 것은 훌륭한 메신저가 되기 위한 여정입니다. 자, 얼른 일어나세요.\n\n\nShiny 사용자 인터페이스\nShiny 앱 Skeleton\n\n\nlibrary(shiny)\n\n# Define UI ----\nui <- fluidPage(\n  \n)\n\n# Define server logic ----\nserver <- function(input, output) {\n  \n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)\n\n\n\n페이지\nShiny 앱의 UI는 하나의 Page로 구성됩니다. 즉, 페이지(page)에 여러 개의 위젯을 배치하여 앱을 구성합니다. 이 Skeleton에서는 fluidPage를 사용하였군요.\n\n페이지는 화가가 그림을 그릴 캔버스라고 이해하면 쉽습니다. 화가가 캔버스에 여러 가지 과일과 꽃 등을 배치하여 정물화를 그리거나, 나무, 산, 강 등을 적절하게 배치하여 풍경화를 그리는 것처럼 Shiny는 페이지에 위젯을 적절하게 배치하여 앱을 개발하는 것입니다.\n\nshiny 페이지\n다음 이미지는 앞에서 실행해 보았던 예제에서 fluidPage로 정의한 UI입니다.\nfluidPage로 정의한 UI그리고 shiny 패키지는 다음과 같은 몇 개의 페이지 함수를 포함하고 있습니다.\n\n\nlibrary(magrittr)\nlibrary(shiny)\n\nls(pos = \"package:shiny\", pattern = \"Page$\") %>% \n  setdiff(\n    ls(pos = \"package:shiny\", pattern = \"^update\")\n  )\n\n\n[1] \"basicPage\"     \"bootstrapPage\" \"fillPage\"      \"fixedPage\"    \n[5] \"fluidPage\"     \"navbarPage\"   \n\n\n유화를 그리는 화가는 캔버스를 준비하지만, 산수화를 그리는 화가는 화선지를 준비하고, 초등학교 미술시간에는 크레파스와 켄트지를 준비하겠지요. 용도에 따라 몇 개의 페이지를 준비해 놓은 것입니다.\n\nshinydashboard 페이지\n다음은 shiny로 대시보드를 구현할 때 사용하는 shinydashboard 패키지의 dashboardPage로 정의한 UI입니다.\ndashboardPageshinydashboard 패키지는 dashboardPage라는 단 하나의 페이지만 제공합니다.\n\n\nlibrary(shinydashboard)\n\nls(pos = \"package:shinydashboard\", pattern = \"Page$\")\n\n\n[1] \"dashboardPage\"\n\n현재 BitStat는 shinydashboard 패키지를 확장한 shinydashboardPlus 패키지의 dashboardPage로 페이지를 구성하고 있습니다.\n레이아웃과 패널\n페이지에 위젯을 보기 좋게 배치하기 위해서 Shiny는 레이아웃(layout)과 패널(panel)을 제공합니다. 레이아웃은 페이지를 가상으로 구획하는 구도이며, 패널은 위젯을 그룹핑하여 패치할 공간을 의미합니다.\n\n화가는 캔버스를 가상으로 나누는 구도를 잡고 사물을 그리는 것처럼 Shiny는 레이아웃으로 구도를 잡고, 패널을 적당하게 배치한 후 패널 안에 비로소 위젯을 채워나갑니다. 즉, 레이아웃과 패널을 적당히 섞어서 앱의 모양(UI)을 정의합니다.\n\n레이아웃\nshiny 패키지는 몇 개의 레이아웃을 제공하는데 앞의 예제처럼 sidebarLayout이 일반적으로 사용됩니다.\n\n\nls(pos = \"package:shiny\", pattern = \"Layout$\") \n\n\n[1] \"flowLayout\"     \"sidebarLayout\"  \"splitLayout\"   \n[4] \"verticalLayout\"\n\n패널\nshiny 패키지는 몇 개의 패널을 제공하는데 앞의 예제에서는 titlePanel, sidebarPanel, mainPanel이 사용되었습니다.\n\n\nls(pos = \"package:shiny\", pattern = \"Panel$\") %>% \n  setdiff(\n    ls(pos = \"package:shiny\", pattern = \"^update\")\n  )\n\n\n [1] \"absolutePanel\"    \"conditionalPanel\" \"fixedPanel\"      \n [4] \"headerPanel\"      \"inputPanel\"       \"mainPanel\"       \n [7] \"navlistPanel\"     \"sidebarPanel\"     \"tabPanel\"        \n[10] \"tabsetPanel\"      \"titlePanel\"       \"wellPanel\"       \n\n레이아웃과 패널의 배치 예제\n다음 예제는 히스토그램을 그리는 예제에서의 레이아웃과 패널의 배치 방법입니다. 위젯을 포함하지 않은 상태입니다.\n\n\nui <- fluidPage(\n  titlePanel(\"title panel\"),\n\n  sidebarLayout(\n    sidebarPanel(\"sidebar panel\"),\n    mainPanel(\"main panel\")\n  )\n)\n\n\n\n위와 같은 배치는 다음 그림과 같은 사이드 바 구도를 만들어 줍니다.\n사이드바 레이아웃sidebarLayout은 일반적으로 sidebarPanel와 mainPanel을 포함합니다. 이것은 왼쪽에 사이드 바 패널을 만들어서 사용자의 입력을 받는 위젯을 배치하고 오른쪽에는 사용자의 입력에 따른 결과를 출력할 메인 패널을 배치하는 방법으로 동작합니다.\ntitlePanel은 이름처럼 앱의 타이틀을 출력할 패널입니다.\nHTML 태그\n아시다시피 Shiny 앱을 HTML로 동작하는 웹 어플리케이션을 의미합니다. 즉, Shiny가 만들어 주는 것은 웹 어플리케이션을 구성하는 HTML, CSS, Javascript입니다.\nR의 htmltools 패키지는 HTML 태그를 만들어 주는 패키지입니다. shiny 패키지가 htmltools 패키지를 이용해서 HTML 태그를 만들어 줍니다.\nHTML 태그를 만드는 함수\nh1() 함수는 첫번째 레벨의 해더를 생성하는 MTML의 <h1> 태그를 만들어 줍니다. 글쓰기에서 장(Chapter)의 타이틀을 만들 때 사용하는 태그입니다. 헤더(Headers)를 만들어 준다고 이해하면 쉽겠지요. 이니셜을 따서 h, 첫번 째라서 1가 됩니다. 합치면 h1가 되겠지요. 숫자가 클수록 글자의 크기가 작아집니다.\nh1() 함수는 다음처럼 <h1> 태그를 만들어 줍니다.\n\nh1(\"A first level header\")\n[1] <h1>A first level header<\/h1>\n\n 그런데, 이 HTML 태그는 웹 브라우저에서 다음과 같이 출력됩니다.\n\nA first level header\n\nshiny 패키지에서 제공하는 대표적인 HTML 태그 함수는 다음과 같습니다.\n함수\nHTML 태그\n의미\np\n<p>\n파라그래프 텍스트\nh1\n<h1>\n첫번째 헤더\nh2\n<h2>\n두번째 헤더\nh3\n<h3>\n세번째 헤더\nh4\n<h4>\n네번째 헤더\nh5\n<h5>\n다섯번째 헤더\nh6\n<h6>\n여섯번째 헤더\nbr\n<br>\n줄 바꿈\nhr\n<hr>\n수평선 긋기\nimg\n<img>\n이미지 삽입\nstrong\n<strong>\n볼드체\ndiv\n<div>\n동일 스타일의 문자 디비젼\nspan\n<span>\n동일 스타일의 문자 인라인\nHTML 태그를 사용 예제\n다음 예제는 여러 종류의 헤더를 출력하는 UI의 설계입니다. 입력 위젯은 포함하지 않은 상태입니다.\n\n\nui <- fluidPage(\n  titlePanel(\"My Shiny App\"),\n  sidebarLayout(\n    sidebarPanel(),\n    mainPanel(\n      h1(\"First level title\"),\n      h2(\"Second level title\"),\n      h3(\"Third level title\"),\n      h4(\"Fourth level title\"),\n      h5(\"Fifth level title\"),\n      h6(\"Sixth level title\")\n    )\n  )\n)\n\n\n\n위와 같은 배치는 다음 그림과 같은 사이드 바 구도를 만들어 줍니다.\n사이드바 레이아웃tutorial\ntutorial에서는 UI 뼈대를 만들기 위해서 fluidPage, sidebarLayout, mainPanel, tabsetPanel을 사용합니다.\nUI 뼈대 만들기 tutorial\n다음 코드를 입력한 후, app.R이라는 이름의 파일로 저장하고 실행해 보세요. 앞에서 다룬 사이드바 레이아웃 그림과 같은 앱이 출력됩니다.\n\n\nlibrary(shiny)\n\n# Define UI ----\nui <- fluidPage(\n  titlePanel(\"title panel\"),\n  \n  sidebarLayout(position = \"right\",\n                sidebarPanel(\"sidebar panel\"),\n                mainPanel(\"main panel\")\n  )\n)\n\n# Define server logic ----\nserver <- function(input, output) {\n  \n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)\n\n\n\nShiny 공식 tutorial 페이지\nShiny 공식 tutorial 페이지를 살펴보고, 사용자 인터페이스를 구축하는 방법을 이해하세요.\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson2/\n추가 예제 실행해 보기\n예제를 실행시켜 보고, tabsetPanel의 기능을 이해하세요. tabsetPanel은 탭 기능으로 여러 출력 위젯을 선택적으로 한 화면에 표현해 줍니다.\n\n\nshiny::runExample(\"06_tabsets\")\n\n\n\n\n\n\n",
      "last_modified": "2022-02-11T23:02:40+09:00"
    }
  ],
  "collections": []
}
